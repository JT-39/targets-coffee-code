---
title: "{targets} 🎯"
title-slide-attributes: 
  data-background-image: _images/targets_hex.png
  data-background-size: 200px
  data-background-position: center 90%
subtitle: "An introduction to the package {`targets`}"
execute: 
  echo: true
  eval: false
format: 
  revealjs:
    hash-type: number
    code-line-numbers: true
---

------------------------------------------------------------------------

## <span style = "color:#4758AB;">{targets}</span> is a pipeline tool

<section class="center">

Use it to coordinate your data analysis projects - TEST

🧑‍💻

</section>

------------------------------------------------------------------------

::: center
## Why use <span style = "color:#4758AB;">{targets}</span>?

🎯
:::

------------------------------------------------------------------------

## Data analysis can be slow and repetitive {autoslide="1000"}

::: r-stack
::: {.fragment width="450" height="300"}
```{dot}
//| label: launch-1
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    node [shape = box style=rounded color=transparent]
    edge [color=transparent]
    {
        A[label="Launch the code" color=black]
        B[label="Wait while it runs" fontcolor=transparent]
        C[label="Discover an issue" fontcolor=transparent]
        D[label="Restart from scratch" fontcolor=transparent]
    }
    A -> B [color=transparent]
    A -> D [dir=back color=transparent]
    B -> C [color=transparent]
    D -> C [dir=back color=transparent]
}
```
:::

::: {.fragment width="450" height="300"}
```{dot}
//| label: wait-1
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    node [shape = box style=rounded color=transparent]
    edge [color=transparent]
    {
        A[label="Launch the code" color=black]
        B[label="Wait while it runs" color=black]
        C[label="Discover an issue" fontcolor=transparent]
        D[label="Restart from scratch" fontcolor=transparent]
    }
    A -> B [color=black]
    A -> D [dir=back color=transparent]
    B -> C [color=transparent]
    D -> C [dir=back color=transparent]
}
```
:::

::: {.fragment width="450" height="300"}
```{dot}
//| label: discover-1
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    node [shape = box style=rounded color=transparent]
    edge [color=transparent]
    {
        A[label="Launch the code" color=black]
        B[label="Wait while it runs" color=black]
        C[label="Discover an issue" color=black]
        D[label="Restart from scratch" fontcolor=transparent]
    }
    A -> B [color=black]
    A -> D [dir=back color=transparent]
    B -> C [color=black]
    D -> C [dir=back color=transparent]
}
```
:::

::: {.fragment width="450" height="300"}
```{dot}
//| label: restart-1
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    node [shape = box style=rounded color=transparent]
    edge [color=transparent]
    {
        A[label="Launch the code" color=black]
        B[label="Wait while it runs" color=black]
        C[label="Discover an issue" color=black]
        D[label="Restart from scratch" color=black]
    }
    A -> B [color=black]
    A -> D [dir=back color=transparent]
    B -> C [color=black]
    D -> C [dir=back color=black]
}
```
:::

::: {.fragment width="450" height="300"}
```{dot}
//| label: full-1
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    {
    node [shape = box style=rounded]
        A[label="Launch the code"]
        B[label="Wait while it runs"]
        C[label="Discover an issue"]
        D[label="Restart from scratch"]
    }
    A -> B
    A -> D [dir=back]
    B -> C
    D -> C [dir=back]
}
```
:::

::: {.fragment width="450" height="300"}
```{dot}
//| label: launch-2
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    node [shape = box style=rounded color=transparent]
    edge [color=transparent]
    {
        A[label="Launch the code" color=black]
        B[label="Wait while it runs" fontcolor=transparent]
        C[label="Discover an issue" fontcolor=transparent]
        D[label="Restart from scratch" fontcolor=transparent]
    }
    A -> B [color=transparent]
    A -> D [dir=back color=transparent]
    B -> C [color=transparent]
    D -> C [dir=back color=transparent]
}
```
:::

::: {.fragment width="450" height="300"}
```{dot}
//| label: wait-2
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    node [shape = box style=rounded color=transparent]
    edge [color=transparent]
    {
        A[label="Launch the code" color=black]
        B[label="Wait while it runs" color=black]
        C[label="Discover an issue" fontcolor=transparent]
        D[label="Restart from scratch" fontcolor=transparent]
    }
    A -> B [color=black]
    A -> D [dir=back color=transparent]
    B -> C [color=transparent]
    D -> C [dir=back color=transparent]
}
```
:::

::: {.fragment width="450" height="300"}
```{dot}
//| label: discover-2
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    node [shape = box style=rounded color=transparent]
    edge [color=transparent]
    {
        A[label="Launch the code" color=black]
        B[label="Wait while it runs" color=black]
        C[label="Discover an issue" color=black]
        D[label="Restart from scratch" fontcolor=transparent]
    }
    A -> B [color=black]
    A -> D [dir=back color=transparent]
    B -> C [color=black]
    D -> C [dir=back color=transparent]
}
```
:::

::: {.fragment width="450" height="300"}
```{dot}
//| label: restart-2
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    node [shape = box style=rounded color=transparent]
    edge [color=transparent]
    {
        A[label="Launch the code" color=black]
        B[label="Wait while it runs" color=black]
        C[label="Discover an issue" color=black]
        D[label="Restart from scratch" color=black]
    }
    A -> B [color=black]
    A -> D [dir=back color=transparent]
    B -> C [color=black]
    D -> C [dir=back color=black]
}
```
:::

::: {.fragment width="450" height="300"}
```{dot}
//| label: full-2
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    {
    node [shape = box style=rounded]
        A[label="Launch the code"]
        B[label="Wait while it runs"]
        C[label="Discover an issue"]
        D[label="Restart from scratch"]
    }
    A -> B
    A -> D [dir=back]
    B -> C
    D -> C [dir=back]
}
```
:::

::: {.fragment width="450" height="300"}
```{dot}
//| label: launch-3
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    node [shape = box style=rounded color=transparent]
    edge [color=transparent]
    {
        A[label="Launch the code" color=black]
        B[label="Wait while it runs" fontcolor=transparent]
        C[label="Discover an issue" fontcolor=transparent]
        D[label="Restart from scratch" fontcolor=transparent]
    }
    A -> B [color=transparent]
    A -> D [dir=back color=transparent]
    B -> C [color=transparent]
    D -> C [dir=back color=transparent]
}
```
:::
:::

------------------------------------------------------------------------

## How does <span style = "color:#4758AB;">{targets}</span> combat this?

<section class="left-align">

<br><br>

::: left
::: fragment
1.  Skips unchanged code/ steps 🏃
:::

::: fragment
2.  Evidence that `code = results` 🔬
:::

::: fragment
3.  Produces code dependency graphs 🦾
:::

::: fragment
4.  Makes parallel computing easy 🔀
:::
:::

</section>

::: notes
-   Watches the workflow and skips steps (targets) whose code,
data & upstream dependencies have not changed.
-   When all targets are up to date,
evidence that results match the code.
    -   Trust results.
    -   Confirm computation is reproducible
:::

------------------------------------------------------------------------

<section class="center">

"{`targets`} implicitly nudges users toward a clean,
function-oriented programming style that fits the intent of the
R language"

</section>

------------------------------------------------------------------------

## Setup

<br><br>

```{r}
#| label: targets-install

install.packages("targets")
```

------------------------------------------------------------------------

## Create an R project

<br><br>

```{r}
#| label: setup-proj

usethis::create_project(path = r"(C:\Users\jtufts\Documents\targets-demo)")
```

<br>

::: callout-tip
<section style="text-align: left;">

Quick plug that you can use my package to create a
pre-populated R project directory!

```{r}
#| label: setup-dauRtemplate

dauRtemplate::dau_proj_template(path = r"(C:\Users\jtufts\Documents\targets-demo)")
```

<br>

More information here:
<span class="link-underlined">[https://github.com/JT-39/dau-R-template-ext]({{< env url_dauR_template >}}){target="_blank"}</span>

</section>
:::

------------------------------------------------------------------------

## Develop your data pipeline

<br><br>

The project directory could look something like...

<br>

``` {.bash .code code-line-numbers="false"}
├── analysis.R
├── _data/
│   ├── raw_data.csv
├── R/
│   ├── functions.R
```

------------------------------------------------------------------------

## Absence data

<br>

![](_images/absence_data.png){style="border: 2px solid grey;"}

------------------------------------------------------------------------

## analysis.R

<br>

```{r}
#| label: analysis

source(here::here("src/R/functions.R"))

# Path to absence data
absence_data_file_path <- here::here("_data/raw/1_absence_3term_nat_reg_la.csv")

# Extract national absence and format date
df_nat_absence <- get_nat_absence_data(absence_data_file_path) |>
  format_time_period()

# Fit a linear model
model <- fit_model(df_nat_absence)

# Plot the data and model
plot_model(model, df_nat_absence)
```

------------------------------------------------------------------------

## functions.R

<br>

```{r}
#| label: functions

# Pull national absence from file
get_nat_absence_data <- function(file_path) {
  read.csv(file = file_path) |>
    dplyr::filter(geographic_level == "National")
}

# Extract the start year from academic year
extract_year <- function(date) {
  paste0(substr(date, 1, 4))
}

# Format the year as a date
format_time_period <- function(data) {
  data |>
    dplyr::mutate(Date = lubridate::year(as.Date(extract_year(time_period),
                                                 format = "%Y")),
                  .after=time_period)
}


# Fit the model and pull coefficients
fit_model <- function(data) {
  lm(sess_overall_percent_pa_10_exact ~ Date, data) |>
    coefficients()
}

# Round to the nearets multiple of five
round_to_multiple_five <- function(x) {
  ceiling((x + 1)/5)*5
}

# Plot the data and model
plot_model <- function(model, data) {
  ggplot2::ggplot(data) +
    ggplot2::geom_point(ggplot2::aes(x = Date,
                                     y = sess_overall_percent_pa_10_exact,
                                     colour = school_type)) +
    ggplot2::geom_line(ggplot2::aes(x = Date,
                                     y = sess_overall_percent_pa_10_exact,
                                     colour = school_type)) +
    ggplot2::scale_colour_manual(values = kasstylesr::color_picker(4),
                                 breaks = c("Total", "State-funded primary",
                                            "State-funded secondary", "Special")) +
    ggplot2::geom_abline(intercept = model[1],
                         slope = model[2],
                         show.legend = T,
                         colour="red",
                         linetype="dashed") +
    ggplot2::annotate("text",
                      x = max(data$Date),
                      y = lm(sess_overall_percent_pa_10_exact ~ Date,
                             df_nat_absence) |>
                        fitted.values() |>
                        max(),
                      hjust = -0.45,
                      label = "Line of best fit",
                      colour = "red") +
    ggplot2::scale_y_continuous(breaks = scales::pretty_breaks(),
                                limits = function(x) {
                                  c(0, round_to_multiple_five(max(x)))
                                }) +
    ggplot2::coord_cartesian(clip = 'off') +
    ggplot2::theme_minimal() +
    kasstylesr::kas_style() +
    ggplot2::labs(
      title = "Average persistent absence over time in England",
      subtitle = "Split by school type. Only includes persistent absentees.",
      x = "",
      y = "Overall absence rate (%)",
      colour = "School type:"
    )
}
```

------------------------------------------------------------------------

## Now make a <span style = "color:#4758AB;">{targets}</span> pipeline

<br><br>

``` {.bash .code code-line-numbers="false"}
├── _targets_analysis.R*
├── _data/
│   ├── raw_data.csv
├── R/
│   ├── functions.R
```

------------------------------------------------------------------------

## Create a <span style = "color:#4758AB;">{targets}</span> template

<br>

```{r}
#| label: targets-script

targets::tar_script()
```

<br>

![](_images/tar_script.png){style="border: 2px solid grey;"}

------------------------------------------------------------------------

## There are 3 parts to the pipeline

<section class="left-align">

::: {.fragment .fade-in-then-semi-out}
1.  Packages are loaded

```{r}
#| label: targets-pkgs
#| eval: true

library(targets)
```
:::

::: {.fragment .fade-in-then-semi-out}
2.  Pipeline-specific options are set

```{r}
#| label: targets-options

tar_option_set(packages = "utils")
tar_source(here::here("R/functions.R"))
```
:::

::: {.fragment .fade-in}
3.  The pipeline itself, a series of *targets*

```{r}
#| label: targets-pipeline

list(
  tar_target(name = data,
             command = data.frame(x = sample.int(100),
                                  y = sample.int(100))),
  tar_target(name = data_summary,
             command = summarize_data(data))
)
```
:::

</section>

::: notes
-   Due to the execution of the pipeline in parallel,
load packages used in pipeline seperately.
    -   So the pkgs are available to all workers.
-   At the top of the script, think “pipeline infrastructure” packages
({targets} and some others).
-   Inside tar_option_set() think
“functions that run inside the pipeline” packages.
:::

------------------------------------------------------------------------

## The <span style = "color:#4758AB;">{targets}</span> pipeline

<br><br>

<section class="left-align">

::: {.fragment .fade-in-then-semi-out}
-   It is simply a list of *targets* 🎯
:::

::: {.fragment .fade-in-then-semi-out}
-   A target is defined using `tar_target()`
:::

::: {.fragment .fade-in}
-   Each has 2 necessary inputs
    -   `name`
    -   `command` \~ the function that generates the target
:::

</section>

------------------------------------------------------------------------

## The <span style = "color:#4758AB;">{targets}</span> pipeline

<br>

<section class="left-align">

::: fragment
So... a target defined as:

```{r}
#| label: target-target

tar_target(name = y, command = f(x))
```
:::

<br>

::: {.fragment .fade-in}
Can be understood as:

```{r}
#| label: target-fun

y <- f(x)
```
:::

<br>

::: {.fragment .fade-in}
-   Targets after this can use the output of previous targets
:::

</section>

::: notes
-   A target is really just a step in the analysis pipeline
:::

------------------------------------------------------------------------

## The <span style = "color:#4758AB;">{targets}</span> pipeline

<br>

![](./_images/targets_pipeline.png){style="border: 2px solid grey;"}

------------------------------------------------------------------------

## Build the pipeline

<br><br>

```{r}
#| label: targets-destroy
#| eval: true
#| echo: false

targets::tar_destroy(destroy = "all",ask = F)
```

```{r}
#| label: targets-make
#| eval: true

tar_make(script = "src/_targets_analysis.R")
```

------------------------------------------------------------------------

## An empty global environment?

<br>

![](_images/empty_environment.png){style="border: 2px solid grey;"}

------------------------------------------------------------------------

## What is going on?

<br><br>

<section class="left-align">

::: {.fragment .fade-in-then-semi-out}
-   {`targets`} creates a pipeline of pure functions
:::

::: {.fragment .fade-in-then-semi-out}
-   Running the pipeline does not depend on the global environment 🌍
:::

::: {.fragment .fade-in-then-semi-out}
-   It also does not change anything outside its scope 🔭
:::

::: {.fragment .fade-in-then-semi-out}
-   The pipeline is **PURE**
:::

</section>

------------------------------------------------------------------------

## <span style = "color:#4758AB;">_targets/</span>

<br><br>

<section class="left-align">

::: {.fragment .fade-in-then-semi-out}
-   The outputs are stored in `_targets/objects/`
:::

::: {.fragment .fade-in-then-semi-out}
-   Each target is saved as an object in the `.rds` format
:::

::: {.fragment .fade-in-then-semi-out}
-   So, you **MUST** add `_targets/` to `.gitignore`
(for GitHub)
☝️
:::

</section>

------------------------------------------------------------------------

## <span style = "color:#4758AB;">_targets/</span>

<br>

::: {.fragment .fade-in}

```{.bash .code code-line-numbers="false"}
_targets/
├── meta
│   ├── meta
│   ├── process
│   └── progress
├── objects
│   ├── model
│   ├── nat_data
│   └── nat_data_clean
└── user
```
:::

<br>

::: {.fragment .fade-in-then}

![](_images/_targets_objects.png){style="border: 2px solid grey;"}
:::

------------------------------------------------------------------------

## <span style = "color:#4758AB;">_targets/</span>

<br>

<section class="left-align">

::: {.fragment .fade-in-then-out}
To display targets:

```{r}
#| label: tar-read
#| eval: true

tar_read(model)
```
:::

<br>

::: {.fragment .fade-in-then-out}
To load targets into the global environment:

```{r}
#| label: tar-load

tar_load(model)
```
:::

</section>

::: notes
-   Well not strictly pure...
-   `.rds` is a R-specific format to save *any* type of object
-   Can be save and read with `saveRDS()` and `readRDS()`
-   Also should note that the pipeline is composition of pure functions.
-   Pure functions:
    -   Referentially transparent function is a function that does not
    use any variable that is not also one of its inputs.
    -   A function that does not interact in any way with the
    global environment.
-   Functions with only side-effects will be difficult to handle.
For example, `base::plot()`
:::

------------------------------------------------------------------------

## Handling files

<br>

::: {.callout-warning title="Advanced"}
<section class="left-align">

::: {.fragment .fade-in}
-   **MUST** use the data's file path initially (and `format = "file"`)
:::

::: {.fragment .fade-in}
```{r}
#| label: targets-file

targets::tar_target(
    name = data,
    command = here::here("_data/raw/1_absence_3term_nat_reg_la.csv"),
    format = "file"
)
```
:::

::: {.fragment .fade-in}
-   Then use the file path target to read in the data
:::

::: {.fragment .fade-in}
```{r}
#| label: targets-load_data

targets::tar_target(
    name = nat_data,
    command = read.csv(data)
)
```
:::

::: {.fragment .fade-in}
-   Otherwise, {`targets`} will not track the data (any changes to it)
:::

</section>
:::

------------------------------------------------------------------------

## File Big Brother

<br><br>

<section class="left-align">

::: {.fragment .fade-in-then-semi-out}
-   {`targets`} keeps track of changes in files and functions 🕵️
:::

::: {.fragment .fade-in-then-semi-out}
-   Any changes will result in the targets being identified as out-of-date
:::

::: {.fragment .fade-in-then-semi-out}
-   So, are re-computed (and their dependencies)
:::

::: {.fragment .fade-in-then-semi-out}
-   We can visualise this...
:::

</section>

------------------------------------------------------------------------

## Code dependency graph

<br> ![](./_images/complete_code_dependency_graph.png){style="border: 2px solid grey;"}

------------------------------------------------------------------------

## Let's change something

<br><br>

<section style="text-align: left;">

::: {.fragment .fade-in}
-   We now filter out the years 2020 & 2021

```{r}
#| label: targets-filter_covid

format_time_period <- function(data) {
  data |>
    ... |>
    dplyr::filter(Date %in% c(2020, 2021))
}
```
:::

</section>

------------------------------------------------------------------------

## Let's change something

<br>

::: {.fragment .fade-in width="450" height="300"}
![](./_images/incomplete_code_dependency_graph.png){style="border: 2px solid grey;"}
:::

::: notes
-   The graph will also highlight in red if there is an
error in the pipeline.
:::

------------------------------------------------------------------------

## Parallel computation

<br>

<section class="left-align">

::: {.fragment .fade-in-then-semi-out}
-   Can run any independent steps (*targets*) in parallel 🔀
:::

::: {.fragment .fade-in-then-semi-out}
-   We are able to harness any GPU cores available, cutting computation time ✂️
:::

::: {.fragment .fade-in-then-semi-out}
-   {`targets`} knows which parts of the pipeline can be ran in parallel
:::

::: {.fragment .fade-in-then-semi-out}
-   To set this up...
:::

</section>

::: notes
-   Also could be useful on DataBricks where more cores and
nodes may be available.
:::

------------------------------------------------------------------------

## Parallel computation

<br>

<section class="left-align">

::: {.fragment .fade-in-then-out}
Need to load a few more packages:

```{r}
#| label: parallel-pkg

library(targets)
library(future)
library(future.callr)
plan(callr)
```
:::

::: {.fragment .fade-in-then-out}
Utilise the {`targets`} function to run in parallel:

```{r}
#| label: targets-parallel

# Set workers = 2 to use 2 cpu cores
targets::tar_make_future(workers = 2)
```
:::

::: {.fragment .fade-in}
Simple as that! 💥
:::

</section>

::: notes
-   Most of our laptops have around 7 cores.
-   Don't use all the cores though as some are needed for
background computer stuff!
:::

------------------------------------------------------------------------

::: center
## Other features

🔮
:::

------------------------------------------------------------------------

## RMarkdown & Quarto

<br>

<section style="text-align: left;">

::: {.fragment .fade-in-then-semi-out}
-   Can include the rendering of a `.Rmd` or `.qmd` to the pipeline
:::

::: {.fragment .fade-in-then-semi-out}
-   Utilises the power of the {`targets`} computation 🔋
:::

<br>

::: r-stack
::: {.fragment .fade-in-then-out}
Load package needed

```{r}
#| label: targets-md

libray(tarchetypes)
```
:::

::: {.fragment .fade-in-then-out}
Function to render Quarto file in the pipeline

```{r}
#| label: targets-render

tar_render(
  my_doc,
  "my_document.qmd"
)
```
:::

::: {.fragment .fade-in-then-out}
How to load targets in the Quarto file

```{{r}}
tar_read(plot)
```
:::
:::

</section>

------------------------------------------------------------------------

## SQL

<section class="left-align">

::: {.fragment .fade-in-then-out}
-   When executing code to SQL you will need to create
connect and disconnect each time 🔌

```{r}
#| label: targets-sql_conn

function(yml_key) {
  conn <- connect_sql_db(yml_key)
  on.exit(DBI::dbDisconnect(conn, shutdown = TRUE))

  DBI::dbGetQuery(...)}
```
:::

::: {.fragment .fade-in}
-   Also the package {`sqltargets`} which applies {`targets`}
principles to .sql files 📦
:::

::: r-stack
::: {.fragment .fade-in-then-out}
```{sql}
#| label: sqltargets

-- !preview conn=DBI::dbConnect(RSQLite::SQLite())
-- tar_load(query_params)
select id
from table
where age > {age_threshold}
```
:::

::: {.fragment .fade-in}
```{r}
#| label: tar_sql

tar_sql(query, path = "query.sql", query_params = query_params)
```
:::
:::

</section>

::: notes
-   SQL connection repetitio is to ensure the connection is
closed and is reusable
:::

------------------------------------------------------------------------

## Key takeaways

<br><br>

<section class="left-align">

::: {.fragment .fade-in-then-semi-out}
-   Enforces a modular, function based pipelines ✅ <br>(R best practice!)
:::

::: {.fragment .fade-in-then-semi-out}
-   Tracks changes to datasets and functions 🔍
:::

::: {.fragment .fade-in-then-semi-out}
-   Provides efficient computation of pipelines ♻️
:::

</section>

------------------------------------------------------------------------

::: center
## We've hit the target!

🎯
:::

------------------------------------------------------------------------

## Resources, links and email

<br>

<section class="left-align">

-   <span class="link-underlined">[{targets} manual]({{< env targets_pkg_manual >}}){target="_blank"}</span>

-   <span class="link-underlined">[YouTube {targets} walkthrough]({{< env youtube_targets >}}){target="_blank"}</span>

-   <span class="link-underlined">[Ofsted MI {targets} example pipeline GitHub]({{< env ofsted_mi_github >}}){target="_blank"}</span>

-   <span class="link-underlined">[These slides and mini {targets} example GitHub]({{< env slides_github >}}){target="_blank"}</span>

-   <span class="link-underlined">[{sqltargets} GitHub]({{< env sql_targets_git >}}){target="_blank"}</span>

-   <span class="link-underlined">[Building reproducible analytical pipelines with R - targets]({{< env bruno_targets >}}){target="_blank"}</span>

Email me at:

<span style = "color:#4758AB;">jake.tufts@education.gov.uk</span>

</section>
