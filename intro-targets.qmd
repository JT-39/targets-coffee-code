---
title: "{targets} 🎯"
title-slide-attributes: 
  data-background-image: _images/targets_hex.png
  data-background-size: 200px
  data-background-position: center 90%
subtitle: "An introduction to the package `{targets}`"
execute: 
  echo: true
  eval: false
format: 
  revealjs:
    hash-type: number
    code-line-numbers: true
---

------------------------------------------------------------------------

## `{targets}` is a pipeline tool

<br>

Use it to coordinate your data analysis projects.

------------------------------------------------------------------------

## Why use `{targets}`?

------------------------------------------------------------------------

## Data analysis can be slow and repetitive {autoslide="1000"}

::: r-stack
::: {.fragment width="450" height="300"}
```{dot}
//| label: launch-1
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    node [shape = box style=rounded color=transparent]
    edge [color=transparent]
    {
        A[label="Launch the code" color=black]
        B[label="Wait while it runs" fontcolor=transparent]
        C[label="Discover an issue" fontcolor=transparent]
        D[label="Restart from scratch" fontcolor=transparent]
    }
    A -> B [color=transparent]
    A -> D [dir=back color=transparent]
    B -> C [color=transparent]
    D -> C [dir=back color=transparent]
}
```
:::

::: {.fragment width="450" height="300"}
```{dot}
//| label: wait-1
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    node [shape = box style=rounded color=transparent]
    edge [color=transparent]
    {
        A[label="Launch the code" color=black]
        B[label="Wait while it runs" color=black]
        C[label="Discover an issue" fontcolor=transparent]
        D[label="Restart from scratch" fontcolor=transparent]
    }
    A -> B [color=black]
    A -> D [dir=back color=transparent]
    B -> C [color=transparent]
    D -> C [dir=back color=transparent]
}
```
:::

::: {.fragment width="450" height="300"}
```{dot}
//| label: discover-1
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    node [shape = box style=rounded color=transparent]
    edge [color=transparent]
    {
        A[label="Launch the code" color=black]
        B[label="Wait while it runs" color=black]
        C[label="Discover an issue" color=black]
        D[label="Restart from scratch" fontcolor=transparent]
    }
    A -> B [color=black]
    A -> D [dir=back color=transparent]
    B -> C [color=black]
    D -> C [dir=back color=transparent]
}
```
:::

::: {.fragment width="450" height="300"}
```{dot}
//| label: restart-1
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    node [shape = box style=rounded color=transparent]
    edge [color=transparent]
    {
        A[label="Launch the code" color=black]
        B[label="Wait while it runs" color=black]
        C[label="Discover an issue" color=black]
        D[label="Restart from scratch" color=black]
    }
    A -> B [color=black]
    A -> D [dir=back color=transparent]
    B -> C [color=black]
    D -> C [dir=back color=black]
}
```
:::

::: {.fragment width="450" height="300"}
```{dot}
//| label: full-1
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    {
    node [shape = box style=rounded]
        A[label="Launch the code"]
        B[label="Wait while it runs"]
        C[label="Discover an issue"]
        D[label="Restart from scratch"]
    }
    A -> B
    A -> D [dir=back]
    B -> C
    D -> C [dir=back]
}
```
:::

::: {.fragment width="450" height="300"}
```{dot}
//| label: launch-2
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    node [shape = box style=rounded color=transparent]
    edge [color=transparent]
    {
        A[label="Launch the code" color=black]
        B[label="Wait while it runs" fontcolor=transparent]
        C[label="Discover an issue" fontcolor=transparent]
        D[label="Restart from scratch" fontcolor=transparent]
    }
    A -> B [color=transparent]
    A -> D [dir=back color=transparent]
    B -> C [color=transparent]
    D -> C [dir=back color=transparent]
}
```
:::

::: {.fragment width="450" height="300"}
```{dot}
//| label: wait-2
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    node [shape = box style=rounded color=transparent]
    edge [color=transparent]
    {
        A[label="Launch the code" color=black]
        B[label="Wait while it runs" color=black]
        C[label="Discover an issue" fontcolor=transparent]
        D[label="Restart from scratch" fontcolor=transparent]
    }
    A -> B [color=black]
    A -> D [dir=back color=transparent]
    B -> C [color=transparent]
    D -> C [dir=back color=transparent]
}
```
:::

::: {.fragment width="450" height="300"}
```{dot}
//| label: discover-2
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    node [shape = box style=rounded color=transparent]
    edge [color=transparent]
    {
        A[label="Launch the code" color=black]
        B[label="Wait while it runs" color=black]
        C[label="Discover an issue" color=black]
        D[label="Restart from scratch" fontcolor=transparent]
    }
    A -> B [color=black]
    A -> D [dir=back color=transparent]
    B -> C [color=black]
    D -> C [dir=back color=transparent]
}
```
:::

::: {.fragment width="450" height="300"}
```{dot}
//| label: restart-2
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    node [shape = box style=rounded color=transparent]
    edge [color=transparent]
    {
        A[label="Launch the code" color=black]
        B[label="Wait while it runs" color=black]
        C[label="Discover an issue" color=black]
        D[label="Restart from scratch" color=black]
    }
    A -> B [color=black]
    A -> D [dir=back color=transparent]
    B -> C [color=black]
    D -> C [dir=back color=black]
}
```
:::

::: {.fragment width="450" height="300"}
```{dot}
//| label: full-2
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    {
    node [shape = box style=rounded]
        A[label="Launch the code"]
        B[label="Wait while it runs"]
        C[label="Discover an issue"]
        D[label="Restart from scratch"]
    }
    A -> B
    A -> D [dir=back]
    B -> C
    D -> C [dir=back]
}
```
:::

::: {.fragment width="450" height="300"}
```{dot}
//| label: launch-3
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    node [shape = box style=rounded color=transparent]
    edge [color=transparent]
    {
        A[label="Launch the code" color=black]
        B[label="Wait while it runs" fontcolor=transparent]
        C[label="Discover an issue" fontcolor=transparent]
        D[label="Restart from scratch" fontcolor=transparent]
    }
    A -> B [color=transparent]
    A -> D [dir=back color=transparent]
    B -> C [color=transparent]
    D -> C [dir=back color=transparent]
}
```
:::
:::

------------------------------------------------------------------------

## How does `{targets}` combat this?

<section style="text-align: left;">

<br><br>

::: left
::: fragment
1.  Skips unchanged code/ steps 🏃
:::

::: fragment
2.  Evidence that `code = results` 🔬
:::

::: fragment
3.  Produces code dependency graphs 🦾
:::

::: fragment
4.  Makes parallel computing easy 🔀
:::
:::

</section>

::: notes
- Watches the workflow and skips steps (targets) whose code,
data & upstream dependencies have not changed.
- When all targets are up to date, evidence that results match the code.
    -   Trust results.
    -   Confirm computation is reproducible
:::

------------------------------------------------------------------------

"`{targets}` implicitly nudges users toward a clean,
function-oriented programming style that fits the intent of the
R language"

------------------------------------------------------------------------

## Setup

<br><br>

```{r}
#| label: targets-install

install.packages("targets")
```

------------------------------------------------------------------------

## Create an R project

<br><br>

```{r}
#| label: setup-proj

usethis::create_project(path = r"(C:\Users\jtufts\Documents\targets-demo)")
```

<br>

::: {.callout-tip}
<section style="text-align: left;">
Quick plug that you can use my package to create a pre-populated
R project directory!
```{r}
#| label: setup-dauRtemplate

dauRtemplate::dau_proj_template(path = r"(C:\Users\jtufts\Documents\targets-demo)")
```

<br>

More information here:
[https://github.com/JT-39/dau-R-template-ext]({{< env url_dauR_template >}}){target="_blank"}
</section>
:::

------------------------------------------------------------------------

## Develop your data pipeline

<br>

The project directory could look something like...

<br>

```{.bash .code}
├── analysis.R
├── _data/
│   ├── raw_data.csv
├── R/
│   ├── functions.R
```

------------------------------------------------------------------------

## Absence data

<br>

![](_images/absence_data.png)

------------------------------------------------------------------------

## analysis.R

<br>

```{r}
#| label: analysis
#| eval: false

source(here::here("src/R/functions.R"))

# Path to absence data
absence_data_file_path <- here::here("_data/raw/1_absence_3term_nat_reg_la.csv")

# Extract national absence and format date
df_nat_absence <- get_nat_absence_data(absence_data_file_path) |>
  format_time_period()

# Fit a linear model
model <- fit_model(df_nat_absence)

# Plot the data and model
plot_model(model, df_nat_absence)
```

------------------------------------------------------------------------

## functions.R

<br>

```{r}
#| label: functions
#| eval: false

# Pull national absence from file
get_nat_absence_data <- function(file_path) {
  read.csv(file = file_path) |>
    dplyr::filter(geographic_level == "National")
}

# Extract the start year from academic year
extract_year <- function(date) {
  paste0(substr(date, 1, 4))
}

# Format the year as a date
format_time_period <- function(data) {
  data |>
    dplyr::mutate(Date = lubridate::year(as.Date(extract_year(time_period),
                                                 format = "%Y")),
                  .after=time_period)
}


# Fit the model and pull coefficients
fit_model <- function(data) {
  lm(sess_overall_percent_pa_10_exact ~ Date, data) |>
    coefficients()
}

# Round to the nearets multiple of five
round_to_multiple_five <- function(x) {
  ceiling((x + 1)/5)*5
}

# Plot the data and model
plot_model <- function(model, data) {
  ggplot2::ggplot(data) +
    ggplot2::geom_point(ggplot2::aes(x = Date,
                                     y = sess_overall_percent_pa_10_exact,
                                     colour = school_type)) +
    ggplot2::geom_line(ggplot2::aes(x = Date,
                                     y = sess_overall_percent_pa_10_exact,
                                     colour = school_type)) +
    ggplot2::scale_colour_manual(values = kasstylesr::color_picker(4),
                                 breaks = c("Total", "State-funded primary",
                                            "State-funded secondary", "Special")) +
    ggplot2::geom_abline(intercept = model[1],
                         slope = model[2],
                         show.legend = T,
                         colour="red",
                         linetype="dashed") +
    ggplot2::annotate("text",
                      x = max(data$Date),
                      y = lm(sess_overall_percent_pa_10_exact ~ Date,
                             df_nat_absence) |>
                        fitted.values() |>
                        max(),
                      hjust = -0.45,
                      label = "Line of best fit",
                      colour = "red") +
    ggplot2::scale_y_continuous(breaks = scales::pretty_breaks(),
                                limits = function(x) {
                                  c(0, round_to_multiple_five(max(x)))
                                }) +
    ggplot2::coord_cartesian(clip = 'off') +
    ggplot2::theme_minimal() +
    kasstylesr::kas_style() +
    ggplot2::labs(
      title = "Average persistent absence over time in England",
      subtitle = "Split by school type. Only includes persistent absentees.",
      x = "",
      y = "Overall absence rate (%)",
      colour = "School type:"
    )
}
```

------------------------------------------------------------------------

## Now make a `{targets}` pipeline

<br><br>

```{.bash .code}
├── _targets_analysis.R**
├── _data/
│   ├── raw_data.csv
├── R/
│   ├── functions.R
```

------------------------------------------------------------------------

## Create a `{targets}` template

<br>

```{r}
#| label: targets-script

targets::tar_script()
```

<br>

![](_images/tar_script.png)

------------------------------------------------------------------------

## There are 3 parts to the pipeline

<br>
<div class="left-align">

::: {.fragment .fade-in-then-semi-out}
1.  Packages are loaded
```{r}
#| label: targets-pkgs
#| eval: true

library(targets)
```
:::

::: {.fragment .fade-in-then-semi-out}
2.  Pipeline-specific options are set
```{r}
#| label: targets-options

tar_option_set(packages = "utils")
tar_source(here::here("R/functions.R"))
```
:::

::: {.fragment .fade-in-then-semi-out}
3.  The pipeline itself, a series of *targets*
```{r}
#| label: targets-pipeline

list(
  tar_target(name = data,
             command = data.frame(x = sample.int(100),
                                  y = sample.int(100))),
  tar_target(name = data_summary,
             command = summarize_data(data))
)
```
:::

</div>

::: notes
- Due to the execution of the pipeline in parallel,
load packages used in pipeline seperately.
    - So the pkgs are available to all workers.
- At the top of the script, think “pipeline infrastructure”
packages ({targets} and some others).
- Inside tar_option_set() think
“functions that run inside the  ipeline” packages.
:::

------------------------------------------------------------------------

## The `{targets}` pipeline

<br>
<div class="left-align">

::: {.fragment .fade-in-then-semi-out}
- It is simply a list of *targets*
:::
::: {.fragment .fade-in-then-semi-out}
- A target is defined using `tar_target()`
:::
::: {.fragment .fade-in-then-semi-out}
- Each has 2 necessary inputs
    - `name`
    - `command` ~ the function that generates the target
:::

</div>

------------------------------------------------------------------------

## The `{targets}` pipeline

<br>
<div class="left-align">

::: {.fragment .fade-in}
So... a target defined as:
```{r}
#| label: target-target

tar_target(name = y, command = f(x))
```
:::
<br>

::: {.fragment .fade-in}
Can be understood as:
```{r}
#| label: target-fun

y <- f(x)
```
:::
<br>

::: {.fragment .fade-in}
- Targets after this can use the output of previous targets
:::

</div>

::: notes
- A target is really just a step in the analysis pipeline
:::

------------------------------------------------------------------------

## Build the pipeline

```{r}
#| label: targets-destroy
#| eval: true
#| echo: false

targets::tar_destroy(destroy = "all",ask = F)
```

```{r}
#| label: targets-make
#| eval: true

tar_make(script = "src/_targets_analysis.R")
```

-----------------------------------------------------------------------

## An empty global environment?

![](_images/empty_environment.png)

------------------------------------------------------------------------

## What is going on?

<div class="left-align">
::: {.fragment .fade-in-then-semi-out}
- `{targets}` creates a pipeline of pure functions
:::
::: {.fragment .fade-in-then-semi-out}
- Running the pipeline does not depend on the global environment
:::
::: {.fragment .fade-in-then-semi-out}
- It also does not change anything outside its scope
:::
::: {.fragment .fade-in-then-semi-out}
- The pipeline is **PURE**
:::
</div>

------------------------------------------------------------------------

## `_targets/`

<br>
<div class="left-align">
::: {.fragment .fade-in-then-semi-out}
- The outputs are stored in `_targets/objects/`
:::
::: {.fragment .fade-in-then-semi-out}
- Each target is saved as in the `.rds` format
:::
::: {.fragment .fade-in-then-semi-out}
- So, **MUST** add `_targets/` to `.gitignore` (for GitHub)
:::
</div>

------------------------------------------------------------------------

## `_targets/`

<br>
<div class="left-align">

::: {.fragment .fade-in-then-out}
To read in targets:
```{r}
#| label: tar-read
#| eval: true

tar_read(model)
```
:::
::: {.fragment .fade-in-then-out}
To load targets into the global environment:
```{r}
#| label: tar-load

tar_load(model)
```
:::

</div>

::: notes
- Well not strictly pure...
- `.rds` is a R-specific format to save *any* type of object
- Can be save and read with `saveRDS()` and `readRDS()`
- Also should note that the pipeline is composition of pure functions.
- Pure functions:
    - Referentially transparent function is a function that does
    not use any variable that is not also one of its inputs.
    - A function that does not interact in any way with the
    global environment.
- Functions with only side-effects will be difficult to handle.
For example, `base::plot()`
:::
------------------------------------------------------------------------

## Handling files

::: {.callout-warning title="Advanced"}
<div class="left-align">

::: {.fragment .fade-in}
- **MUST** use the data's file path initially (and `format` = "file")
:::
::: {.fragment .fade-in}
```{r}
#| label: targets-file

targets::tar_target(
    name = data,
    command = here::here("_data/raw/1_absence_3term_nat_reg_la.csv"),
    format = "file"
)
```
:::
::: {.fragment .fade-in}
- Then use the file path target to read in the data
:::
::: {.fragment .fade-in}
```{r}
#| label: targets-load_data

targets::tar_target(
    name = nat_data,
    command = read.csv(data)
)
```
:::
::: {.fragment .fade-in}
- Otherwise, `{targets}` will not track the data (any changes to it)
:::

</div>

:::

------------------------------------------------------------------------

## File Big Brother

<div class="left-align">
::: {.fragment .fade-in-then-semi-out}
- `{targets}` keeps track of changes in files and functions
:::
::: {.fragment .fade-in-then-semi-out}
- Any changes will result in the targets being identified as out-of-date
:::
::: {.fragment .fade-in-then-semi-out}
- So, are re-computed (and their dependencies)
:::
::: {.fragment .fade-in-then-semi-out}
- We can visualise this...
:::
</div>

------------------------------------------------------------------------

## Code dependency graph

![](./_images/complete_code_dependency_graph.png)

------------------------------------------------------------------------

## Let's change something

::: r-stack
::: {.fragment .fade-in-then-out width="450" height="300"}
<div class="left-align">
- We now filter out the years 2020 & 2021

```{r}
#| label: targets-filter_covid

format_time_period <- function(data) {
  data |>
    ... |>
    dplyr::filter(Date %in% c(2020, 2021))
}
```
</div>

:::
::: {.fragment .fade-in width="450" height="300"}
![](./_images/incomplete_code_dependency_graph.png)
:::
:::

------------------------------------------------------------------------

## Parallel computation

<div class="left-align">
::: {.fragment .fade-in-then-semi-out}
- Can run any indepedent steps (*targets*) in parallel
:::
::: {.fragment .fade-in-then-semi-out}
- We are able to harness any GPU cores available,
cutting computation time
:::
::: {.fragment .fade-in-then-semi-out}
- `{targets}` knows which parts of the pipeline can be ran in parallel
:::
::: {.fragment .fade-in-then-semi-out}
- To set this up...
:::
</div>

::: notes
- Also could be useful on DataBricks where more cores and nodes may
be available.
:::

------------------------------------------------------------------------

## Parallel computation

<div class="left-align">
::: {.fragment .fade-in-then-out}
Need to load a few more packages:

```{r}
#| label: parallel-pkg

library(targets)
library(future)
library(future.callr)
plan(callr)
```
:::
::: {.fragment .fade-in-then-out}
Utilise the `{targets}` function to run in parallel:

```{r}
#| label: targets-parallel

# Set workers = 2 to use 2 cpu cores
targets::tar_make_future(workers = 2)
```
:::
::: {.fragment .fade-in}
Simple as that!
:::

::: notes
- Most of our laptops have around 7 cores.
- Don't use all the cores though as some are needed for background
computer stuff!
:::

------------------------------------------------------------------------

## Other features

------------------------------------------------------------------------

## RMarkdown & Quarto

<section style="text-align: left;">
::: {.fragment .fade-in-then-semi-out}
- Can include the rendering of a `.Rmd` or `.qmd` to the pipeline
:::
::: {.fragment .fade-in-then-semi-out}
- Utilises the power of the `{targets}` computation
:::

::: r-stack
::: {.fragment .fade-in-then-out}
Load package needed
```{r}
#| label: targets-md

libray(tarchetypes)
```
:::
::: {.fragment .fade-in-then-out}
Function to render Quarto file in the pipeline
```{r}
#| label: targets-render

tar_render(
  my_doc,
  "my_document.qmd"
)
```
:::
::: {.fragment .fade-in-then-out}
How to load targets in the Quarto file
```{{r}}
tar_read(plot)
```
:::
:::
</div>

------------------------------------------------------------------------

## SQL


------------------------------------------------------------------------

#### Code walkthrough

<br> <br>

### Scraping Ofsted MI data

<br> <br> <br>

Source code is available at
[https://github.com/JT-39/]({{< env url_targets_git >}}){target="_blank"}

------------------------------------------------------------------------

## Data pipeline

<br>

<section style="text-align: left;">

::: left
::: fragment
1.  Scrape Ofsted data 🍴
:::

::: fragment
2.  Clean the data 🛁
:::

::: fragment
3.  Upload to SQL 📤
:::
:::

</section>

------------------------------------------------------------------------

## Process map

![](_images/ofsted-mi-process-map.jpg)


------------------------------------------------------------------------

## {targets} code dependency graph

