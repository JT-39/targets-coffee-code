---
title: "{targets} ğŸ¯"
title-slide-attributes: 
  data-background-image: _images/targets_hex.png
  data-background-size: 200px
  data-background-position: center 90%
subtitle: "An introduction to the package {`targets`}"
execute: 
  echo: true
  eval: false
format: 
  revealjs:
    hash-type: number
    code-line-numbers: true
---

------------------------------------------------------------------------

## <span style = "color:#4758AB;">{targets}</span> is a pipeline tool

<section class="center">

Use it to coordinate your data analysis projects

ğŸ§‘â€ğŸ’»

</section>

------------------------------------------------------------------------

## Why use <span style = "color:#4758AB;">{targets}</span>? {.center}

ğŸ¯

------------------------------------------------------------------------

<section class="center">

"{`targets`} implicitly nudges users toward a clean,
function-oriented programming style that fits the intent of the
R language"

</section>

------------------------------------------------------------------------

## Data analysis can be slow and repetitive {autoslide="1000"}

::: r-stack
::: {.fragment width="450" height="300"}
```{dot}
//| label: launch-1
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    node [shape = box style=rounded color=transparent]
    edge [color=transparent]
    {
        A[label="Launch the code" color=black]
        B[label="Wait while it runs" fontcolor=transparent]
        C[label="Discover an issue" fontcolor=transparent]
        D[label="Restart from scratch" fontcolor=transparent]
    }
    A -> B [color=transparent]
    A -> D [dir=back color=transparent]
    B -> C [color=transparent]
    D -> C [dir=back color=transparent]
}
```
:::

::: {.fragment width="450" height="300"}
```{dot}
//| label: wait-1
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    node [shape = box style=rounded color=transparent]
    edge [color=transparent]
    {
        A[label="Launch the code" color=black]
        B[label="Wait while it runs" color=black]
        C[label="Discover an issue" fontcolor=transparent]
        D[label="Restart from scratch" fontcolor=transparent]
    }
    A -> B [color=black]
    A -> D [dir=back color=transparent]
    B -> C [color=transparent]
    D -> C [dir=back color=transparent]
}
```
:::

::: {.fragment width="450" height="300"}
```{dot}
//| label: discover-1
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    node [shape = box style=rounded color=transparent]
    edge [color=transparent]
    {
        A[label="Launch the code" color=black]
        B[label="Wait while it runs" color=black]
        C[label="Discover an issue" color=black]
        D[label="Restart from scratch" fontcolor=transparent]
    }
    A -> B [color=black]
    A -> D [dir=back color=transparent]
    B -> C [color=black]
    D -> C [dir=back color=transparent]
}
```
:::

::: {.fragment width="450" height="300"}
```{dot}
//| label: restart-1
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    node [shape = box style=rounded color=transparent]
    edge [color=transparent]
    {
        A[label="Launch the code" color=black]
        B[label="Wait while it runs" color=black]
        C[label="Discover an issue" color=black]
        D[label="Restart from scratch" color=black]
    }
    A -> B [color=black]
    A -> D [dir=back color=transparent]
    B -> C [color=black]
    D -> C [dir=back color=black]
}
```
:::

::: {.fragment width="450" height="300"}
```{dot}
//| label: full-1
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    {
    node [shape = box style=rounded]
        A[label="Launch the code"]
        B[label="Wait while it runs"]
        C[label="Discover an issue"]
        D[label="Restart from scratch"]
    }
    A -> B
    A -> D [dir=back]
    B -> C
    D -> C [dir=back]
}
```
:::

::: {.fragment width="450" height="300"}
```{dot}
//| label: launch-2
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    node [shape = box style=rounded color=transparent]
    edge [color=transparent]
    {
        A[label="Launch the code" color=black]
        B[label="Wait while it runs" fontcolor=transparent]
        C[label="Discover an issue" fontcolor=transparent]
        D[label="Restart from scratch" fontcolor=transparent]
    }
    A -> B [color=transparent]
    A -> D [dir=back color=transparent]
    B -> C [color=transparent]
    D -> C [dir=back color=transparent]
}
```
:::

::: {.fragment width="450" height="300"}
```{dot}
//| label: wait-2
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    node [shape = box style=rounded color=transparent]
    edge [color=transparent]
    {
        A[label="Launch the code" color=black]
        B[label="Wait while it runs" color=black]
        C[label="Discover an issue" fontcolor=transparent]
        D[label="Restart from scratch" fontcolor=transparent]
    }
    A -> B [color=black]
    A -> D [dir=back color=transparent]
    B -> C [color=transparent]
    D -> C [dir=back color=transparent]
}
```
:::

::: {.fragment width="450" height="300"}
```{dot}
//| label: discover-2
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    node [shape = box style=rounded color=transparent]
    edge [color=transparent]
    {
        A[label="Launch the code" color=black]
        B[label="Wait while it runs" color=black]
        C[label="Discover an issue" color=black]
        D[label="Restart from scratch" fontcolor=transparent]
    }
    A -> B [color=black]
    A -> D [dir=back color=transparent]
    B -> C [color=black]
    D -> C [dir=back color=transparent]
}
```
:::

::: {.fragment width="450" height="300"}
```{dot}
//| label: restart-2
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    node [shape = box style=rounded color=transparent]
    edge [color=transparent]
    {
        A[label="Launch the code" color=black]
        B[label="Wait while it runs" color=black]
        C[label="Discover an issue" color=black]
        D[label="Restart from scratch" color=black]
    }
    A -> B [color=black]
    A -> D [dir=back color=transparent]
    B -> C [color=black]
    D -> C [dir=back color=black]
}
```
:::

::: {.fragment width="450" height="300"}
```{dot}
//| label: full-2
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    {
    node [shape = box style=rounded]
        A[label="Launch the code"]
        B[label="Wait while it runs"]
        C[label="Discover an issue"]
        D[label="Restart from scratch"]
    }
    A -> B
    A -> D [dir=back]
    B -> C
    D -> C [dir=back]
}
```
:::

:::

------------------------------------------------------------------------

## Data analysis can be slow and repetitive
```{dot}
//| label: full-end
//| eval: true
//| echo: false

digraph G {
    rankdir=LR;
    {
    node [shape = box style=rounded]
        A[label="Launch the code"]
        B[label="Wait while it runs"]
        C[label="Discover an issue"]
        D[label="Restart from scratch"]
    }
    A -> B
    A -> D [dir=back]
    B -> C
    D -> C [dir=back]
}
```

------------------------------------------------------------------------

## How does <span style = "color:#4758AB;">{targets}</span> combat this?

<section class="left-align">

<br><br>

::: left
::: fragment
1.  Skips unchanged code/ steps ğŸƒ
:::

::: fragment
2.  Evidence that `code = results` ğŸ”¬
:::

::: fragment
3.  Produces code dependency graphs ğŸ¦¾
:::

::: fragment
4.  Makes parallel computing easy ğŸ”€
:::
:::

</section>

::: notes
-   Watches the workflow and skips steps (targets) whose code,
data & upstream dependencies have not changed.
-   When all targets are up to date,
evidence that results match the code.
    -   Trust results.
    -   Confirm computation is reproducible
:::

------------------------------------------------------------------------

## Code walkthrough

<br>
<br>

If you want to follow along in your local R environment,
you can clone the repository at this link:

<br>

<span class="link-underlined">[https://github.com/JT-39/targets-coffee-code-walkthrough]({{< env url_code_walkthrough_git >}}){target="_blank"}</span>

------------------------------------------------------------------------

## Setup

<br><br>

```{r}
#| label: targets-install

install.packages("targets")
```

------------------------------------------------------------------------

## Create an R project

<br><br>

```{r}
#| label: setup-proj

usethis::create_project(path = r"(C:\Users\jtufts\Documents\targets-demo)")
```

<br>

::: {.callout-tip}
<section style="text-align: left;">

Quick plug that you can use my package to create a
pre-populated R project directory!

```{r}
#| label: setup-dauRtemplate

dauRtemplate::dau_proj_template(path = r"(C:\Users\jtufts\Documents\targets-demo)")
```

<br>

More information here:
<span class="link-underlined">[https://github.com/JT-39/dau-R-template-ext]({{< env url_dauR_template >}}){target="_blank"}</span>

</section>

:::

------------------------------------------------------------------------

## Develop your data pipeline

<br><br>

The project directory could look something like...

<br>

``` {.bash .code code-line-numbers="false"}
â”œâ”€â”€ analysis.R
â”œâ”€â”€ _data/
â”‚   â”œâ”€â”€ raw_data.csv
â”œâ”€â”€ R/
â”‚   â”œâ”€â”€ functions.R
```

------------------------------------------------------------------------

## Absence data

<br>

![](_images/absence_data.png){style="border: 2px solid grey;"}

------------------------------------------------------------------------

## analysis.R

<br>

```{r}
#| label: analysis

source(here::here("src/R/functions.R"))

# Path to absence data
absence_data_file_path <- here::here("_data/raw/1_absence_3term_nat_reg_la.csv")

# Extract national absence and format date
df_nat_absence <- get_nat_absence_data(absence_data_file_path) |>
  format_time_period()

# Fit a linear model
model <- fit_model(df_nat_absence)

# Plot the data and model
plot_model(model, df_nat_absence)
```

------------------------------------------------------------------------

## functions.R

<br>

```{r}
#| label: functions

# Pull national absence from file
get_nat_absence_data <- function(file_path) {
  read.csv(file = file_path) |>
    dplyr::filter(geographic_level == "National")
}

# Extract the start year from academic year
extract_year <- function(date) {
  paste0(substr(date, 1, 4))
}

# Format the year as a date
format_time_period <- function(data) {
  data |>
    dplyr::mutate(Date = lubridate::year(as.Date(extract_year(time_period),
                                                 format = "%Y")),
                  .after=time_period)
}


# Fit the model and pull coefficients
fit_model <- function(data) {
  lm(sess_overall_percent_pa_10_exact ~ Date, data) |>
    coefficients()
}

# Round to the nearets multiple of five
round_to_multiple_five <- function(x) {
  ceiling((x + 1)/5)*5
}

# Plot the data and model
plot_model <- function(model, data) {
  ggplot2::ggplot(data) +
    ggplot2::geom_point(ggplot2::aes(x = Date,
                                     y = sess_overall_percent_pa_10_exact,
                                     colour = school_type)) +
    ggplot2::geom_line(ggplot2::aes(x = Date,
                                     y = sess_overall_percent_pa_10_exact,
                                     colour = school_type)) +
    ggplot2::scale_colour_manual(values = kasstylesr::color_picker(4),
                                 breaks = c("Total", "State-funded primary",
                                            "State-funded secondary", "Special")) +
    ggplot2::geom_abline(intercept = model[1],
                         slope = model[2],
                         show.legend = T,
                         colour="red",
                         linetype="dashed") +
    ggplot2::annotate("text",
                      x = max(data$Date),
                      y = lm(sess_overall_percent_pa_10_exact ~ Date,
                             df_nat_absence) |>
                        fitted.values() |>
                        max(),
                      hjust = -0.45,
                      label = "Line of best fit",
                      colour = "red") +
    ggplot2::scale_y_continuous(breaks = scales::pretty_breaks(),
                                limits = function(x) {
                                  c(0, round_to_multiple_five(max(x)))
                                }) +
    ggplot2::coord_cartesian(clip = 'off') +
    ggplot2::theme_minimal() +
    kasstylesr::kas_style() +
    ggplot2::labs(
      title = "Average persistent absence over time in England",
      subtitle = "Split by school type. Only includes persistent absentees.",
      x = "",
      y = "Overall absence rate (%)",
      colour = "School type:"
    )
}
```

------------------------------------------------------------------------

## Now make a <span style = "color:#4758AB;">{targets}</span> pipeline

<br><br>

``` {.bash .code code-line-numbers="false"}
â”œâ”€â”€ _targets_analysis.R*
â”œâ”€â”€ _data/
â”‚   â”œâ”€â”€ raw_data.csv
â”œâ”€â”€ R/
â”‚   â”œâ”€â”€ functions.R
```

------------------------------------------------------------------------

## Create a <span style = "color:#4758AB;">{targets}</span> template

<br>

```{r}
#| label: targets-script

targets::tar_script()
```

<br>

![](_images/tar_script.png){style="border: 2px solid grey;"}

------------------------------------------------------------------------

## There are 3 parts to the pipeline

<section class="left-align">

::: {.fragment .fade-in-then-semi-out}
1.  Packages are loaded

```{r}
#| label: targets-pkgs
#| eval: true

library(targets)
```
:::

::: {.fragment .fade-in-then-semi-out}
2.  Pipeline-specific options are set

```{r}
#| label: targets-options

tar_option_set(packages = "utils")
tar_source(here::here("R/functions.R"))
```
:::

::: {.fragment .fade-in}
3.  The pipeline itself, a series of *targets*

```{r}
#| label: targets-pipeline

list(
  tar_target(name = data,
             command = data.frame(x = sample.int(100),
                                  y = sample.int(100))),
  tar_target(name = data_summary,
             command = summarize_data(data))
)
```
:::

</section>

::: notes
-   Due to the execution of the pipeline in parallel,
load packages used in pipeline seperately.
    -   So the pkgs are available to all workers.
-   At the top of the script, think â€œpipeline infrastructureâ€ packages
({targets} and some others).
-   Inside tar_option_set() think
â€œfunctions that run inside the pipelineâ€ packages.
:::

------------------------------------------------------------------------

## The <span style = "color:#4758AB;">{targets}</span> pipeline

<br><br>

<section class="left-align">

::: {.fragment .fade-in-then-semi-out}
-   It is simply a list of *targets* ğŸ¯
:::

::: {.fragment .fade-in-then-semi-out}
-   A target is defined using `tar_target()`
:::

::: {.fragment .fade-in}
-   Each has 2 necessary inputs
    -   `name`
    -   `command` \~ the function that generates the target
:::

</section>

------------------------------------------------------------------------

## The <span style = "color:#4758AB;">{targets}</span> pipeline

<br>

<section class="left-align">

::: fragment
So... a target defined as:

```{r}
#| label: target-target

tar_target(name = y, command = f(x))
```
:::

<br>

::: {.fragment .fade-in}
Can be understood as:

```{r}
#| label: target-fun

y <- f(x)
```
:::

<br>

::: {.fragment .fade-in}
-   Targets after this can use the output of previous targets
:::

</section>

::: notes
-   A target is really just a step in the analysis pipeline
:::

------------------------------------------------------------------------

## The <span style = "color:#4758AB;">{targets}</span> pipeline

<br>

![](./_images/targets_pipeline.png){style="border: 2px solid grey;"}

------------------------------------------------------------------------

## Build the pipeline

<br><br>

```{r}
#| label: targets-destroy
#| eval: true
#| echo: false

targets::tar_destroy(destroy = "all",ask = F)
```

```{r}
#| label: targets-make
#| eval: true

tar_make(script = "src/_targets_analysis.R")
```

------------------------------------------------------------------------

## An empty global environment?

<br>

![](_images/empty_environment.png){style="border: 2px solid grey;"}

------------------------------------------------------------------------

## What is going on?

<br><br>

<section class="left-align">

::: {.fragment .fade-in-then-semi-out}
-   {`targets`} creates a pipeline of pure functions
:::

::: {.fragment .fade-in-then-semi-out}
-   Running the pipeline does not depend on the global environment ğŸŒ
:::

::: {.fragment .fade-in-then-semi-out}
-   It also does not change anything outside its scope ğŸ”­
:::

::: {.fragment .fade-in-then-semi-out}
-   The pipeline is **PURE**
:::

</section>

------------------------------------------------------------------------

## <span style = "color:#4758AB;">_targets/</span>

<br><br>

<section class="left-align">

::: {.fragment .fade-in-then-semi-out}
-   The outputs are stored in `_targets/objects/`
:::

::: {.fragment .fade-in-then-semi-out}
-   Each target is saved as an object in the `.rds` format
:::

::: {.fragment .fade-in-then-semi-out}
-   So, you **MUST** add `_targets/` to `.gitignore`
(for GitHub)
â˜ï¸
:::

</section>

------------------------------------------------------------------------

## <span style = "color:#4758AB;">_targets/</span>

<br>

::: {.fragment .fade-in}

```{.bash .code code-line-numbers="false"}
_targets/
â”œâ”€â”€ meta
â”‚   â”œâ”€â”€ meta
â”‚   â”œâ”€â”€ process
â”‚   â””â”€â”€ progress
â”œâ”€â”€ objects
â”‚   â”œâ”€â”€ model
â”‚   â”œâ”€â”€ nat_data
â”‚   â””â”€â”€ nat_data_clean
â””â”€â”€ user
```
:::

<br>

::: {.fragment .fade-in-then}

![](_images/_targets_objects.png){style="border: 2px solid grey;"}
:::

------------------------------------------------------------------------

## <span style = "color:#4758AB;">_targets/</span>

<br>

<section class="left-align">

::: {.fragment .fade-in-then-out}
To display targets:

```{r}
#| label: tar-read
#| eval: true

tar_read(model)
```
:::

</section>

::: notes
-   Well not strictly pure...
-   `.rds` is a R-specific format to save *any* type of object
-   Can be save and read with `saveRDS()` and `readRDS()`
-   Also should note that the pipeline is composition of pure functions.
-   Pure functions:
    -   Referentially transparent function is a function that does not
    use any variable that is not also one of its inputs.
    -   A function that does not interact in any way with the
    global environment.
-   Functions with only side-effects will be difficult to handle.
For example, `base::plot()`
:::

------------------------------------------------------------------------

## <span style = "color:#4758AB;">_targets/</span>

<br>

<section class="left-align">

::: {.fragment .fade-in-then-out}
To load targets into the global environment:

```{r}
#| label: tar-load

tar_load(model)
```

<br>

![](_images/tar_load_global_env.png){style="border: 2px solid grey;"}

:::

</section>

------------------------------------------------------------------------

## Handling files

<br>

::: {.callout-warning title="Advanced"}
<section class="left-align">

::: {.fragment .fade-in}
-   **MUST** use the data's file path initially (and `format = "file"`)
:::

::: {.fragment .fade-in}
```{r}
#| label: targets-file

targets::tar_target(
    name = data,
    command = here::here("_data/raw/1_absence_3term_nat_reg_la.csv"),
    format = "file"
)
```
:::

::: {.fragment .fade-in}
-   Then use the file path target to read in the data
:::

::: {.fragment .fade-in}
```{r}
#| label: targets-load_data

targets::tar_target(
    name = nat_data,
    command = read.csv(data)
)
```
:::

::: {.fragment .fade-in}
-   Otherwise, {`targets`} will not track the data (any changes to it)
:::

</section>
:::

------------------------------------------------------------------------

## File Big Brother

<br><br>

<section class="left-align">

::: {.fragment .fade-in-then-semi-out}
-   {`targets`} keeps track of changes in files and functions ğŸ•µï¸
:::

::: {.fragment .fade-in-then-semi-out}
-   Any changes will result in the targets being identified as out-of-date
:::

::: {.fragment .fade-in-then-semi-out}
-   So, are re-computed (and their dependencies)
:::

::: {.fragment .fade-in-then-semi-out}
-   We can visualise this...
:::

</section>

------------------------------------------------------------------------

## Code dependency graph

<br>

```{r}
#| label: targets-visnetwork

targets::tar_visnetwork(script = "src/_targets_analysis.R")
```

![](./_images/complete_code_dependency_graph.png){style="border: 2px solid grey;"}

------------------------------------------------------------------------

## Let's change something

<br><br>

<section style="text-align: left;">

::: {.fragment .fade-in}
-   We now filter out the years 2020 & 2021

```{r}
#| label: targets-filter_covid

format_time_period <- function(data) {
  data |>
    ... |>
    dplyr::filter(!Date %in% c(2020, 2021))
}
```
:::

</section>

------------------------------------------------------------------------

## Let's change something

<br>

```{r}
#| label: targets-visnetwork-change

targets::tar_visnetwork(script = "src/_targets_analysis.R")
```


::: {.fragment .fade-in width="450" height="300"}
![](./_images/incomplete_code_dependency_graph.png){style="border: 2px solid grey;"}
:::

::: notes
-   The graph will also highlight in red if there is an
error in the pipeline.
:::

------------------------------------------------------------------------

## These can be embedded graphs...

<br>

```{mermaid}
%%| eval: true
%%| echo: false

graph LR
style Legend fill:#FFFFFF00,stroke:#000000
style Graph fill:#FFFFFF00,stroke:#000000;
  subgraph Legend
    direction LR
    xf1522833a4d242c5([Up to date]):::uptodate --- xd03d7c7dd2ddda2b([Stem]):::none
    xd03d7c7dd2ddda2b([Stem]):::none --- xeb2d7cac8a1ce544>Function]:::none
  end
  subgraph Graph
    direction LR
    xb1fbb690b4ec8c10>extract_year]:::uptodate --> xd20a83ce47f3194c>format_time_period]:::uptodate
    xf7d598eca7911241>round_to_multiple_five]:::uptodate --> xec203b5a68d60f72>plot_model]:::uptodate
    xd20a83ce47f3194c>format_time_period]:::uptodate --> xc2980a3d74445b80([nat_data_clean]):::uptodate
    x83c942fcaf37c3dc([nat_data]):::uptodate --> xc2980a3d74445b80([nat_data_clean]):::uptodate
    x0d01c84c9424364d([data_file]):::uptodate --> x83c942fcaf37c3dc([nat_data]):::uptodate
    x9242f8c59a209716>get_nat_absence_data]:::uptodate --> x83c942fcaf37c3dc([nat_data]):::uptodate
    x9043e9d6bef6a839([model]):::uptodate --> x667cd56a75e2bb2b([plot]):::uptodate
    xc2980a3d74445b80([nat_data_clean]):::uptodate --> x667cd56a75e2bb2b([plot]):::uptodate
    xec203b5a68d60f72>plot_model]:::uptodate --> x667cd56a75e2bb2b([plot]):::uptodate
    x12e88730e39644dc>fit_model]:::uptodate --> x9043e9d6bef6a839([model]):::uptodate
    xc2980a3d74445b80([nat_data_clean]):::uptodate --> x9043e9d6bef6a839([model]):::uptodate
  end
classDef uptodate stroke:#000000,color:#ffffff,fill:#354823;
classDef none stroke:#000000,color:#000000,fill:#94a4ac;
linkStyle 0 stroke-width:0px;
linkStyle 1 stroke-width:0px;

```

------------------------------------------------------------------------

## ... or save them as a .html

<br> 

```{r}
#| label: targets-vis-save

htmltools::save_html(html = targets::tar_visnetwork("src/_targets_analysis.R"),
                     file = "_outputs/code_pipeline.html")
```

::: {.fragment .fade-in width="450" height="300"}
![](./_images/errored_code_dependency_graph.png){style="border: 2px solid grey;" height="450" width="800"}
:::


------------------------------------------------------------------------

## Parallel computation

<br>

<section class="left-align">

::: {.fragment .fade-in-then-semi-out}
-   Can run any independent steps (*targets*) in parallel ğŸ”€
:::

::: {.fragment .fade-in-then-semi-out}
-   We are able to harness any GPU cores available, cutting computation time âœ‚ï¸
:::

::: {.fragment .fade-in-then-semi-out}
-   {`targets`} knows which parts of the pipeline can be ran in parallel
:::

::: {.fragment .fade-in-then-semi-out}
-   To set this up...
:::

</section>

::: notes
-   Also could be useful on DataBricks where more cores and
nodes may be available.
:::

------------------------------------------------------------------------

## Parallel computation

<br>

<section class="left-align">

::: {.fragment .fade-in-then-out}
Need to load a few more packages:

```{r}
#| label: parallel-pkg

library(targets)
library(future)
library(future.callr)
plan(callr)
```
:::

::: {.fragment .fade-in-then-out}
Utilise the {`targets`} function to run in parallel:

```{r}
#| label: targets-parallel

# Set workers = 2 to use 2 cpu cores
targets::tar_make_future(workers = 2)
```
:::

::: {.fragment .fade-in}
Simple as that! ğŸ’¥
:::

</section>

::: notes
-   Most of our laptops have around 7 cores.
-   Don't use all the cores though as some are needed for
background computer stuff!
:::

------------------------------------------------------------------------

## Other features {.center}

ğŸ”®

------------------------------------------------------------------------

## RMarkdown & Quarto

<br>

<section style="text-align: left;">

::: {.fragment .fade-in-then-semi-out}
-   Can include the rendering of a `.Rmd` or `.qmd` to the pipeline
:::

::: {.fragment .fade-in-then-semi-out}
-   Utilises the power of the {`targets`} computation ğŸ”‹
:::

<br>

::: r-stack
::: {.fragment .fade-in-then-out}
Load package needed

```{r}
#| label: targets-md

libray(tarchetypes)
```
:::

::: {.fragment .fade-in-then-out}
Function to render Quarto file in the pipeline

```{r}
#| label: targets-render

tar_render(
  my_doc,
  "my_document.qmd"
)
```
:::

::: {.fragment .fade-in-then-out}
How to load targets in the Quarto file

```{{r}}
tar_read(plot)
```
:::
:::

</section>

------------------------------------------------------------------------

## SQL

<section class="left-align">

::: {.fragment .fade-in-then-out}
-   When executing code to SQL you will need to create
connect and disconnect each time ğŸ”Œ

```{r}
#| label: targets-sql_conn

function(yml_key) {
  conn <- connect_sql_db(yml_key)
  on.exit(DBI::dbDisconnect(conn, shutdown = TRUE))

  DBI::dbGetQuery(...)}
```
:::

::: {.fragment .fade-in}
-   Also the package {`sqltargets`} which applies {`targets`}
principles to .sql files ğŸ“¦
:::

::: r-stack
::: {.fragment .fade-in-then-out}
```{sql}
#| label: sqltargets

-- !preview conn=DBI::dbConnect(RSQLite::SQLite())
-- tar_load(query_params)
select id
from table
where age > {age_threshold}
```
:::

::: {.fragment .fade-in}
```{r}
#| label: tar_sql

tar_sql(query, path = "query.sql", query_params = query_params)
```
:::
:::

</section>

::: notes
-   SQL connection repetitio is to ensure the connection is
closed and is reusable
:::

------------------------------------------------------------------------

## Key takeaways

<br><br>

<section class="left-align">

::: {.fragment .fade-in-then-semi-out}
-   Enforces a modular, function based pipelines âœ… <br>(R best practice!)
:::

::: {.fragment .fade-in-then-semi-out}
-   Tracks changes to datasets and functions ğŸ”
:::

::: {.fragment .fade-in-then-semi-out}
-   Provides efficient computation of pipelines â™»ï¸
:::

</section>

------------------------------------------------------------------------

## We've hit the target! {.center}

ğŸ¯

------------------------------------------------------------------------

## Resources, links and email

<br>

<section class="left-align">

- {targets} manual: <span class="link-underlined">[Link]({{< env targets_pkg_manual >}}){target="_blank"}</span>

- YouTube {targets} walkthrough: <span class="link-underlined">[Link]({{< env youtube_targets >}}){target="_blank"}</span>

- Ofsted MI {targets} example pipeline GitHub: <span class="link-underlined">[Link]({{< env ofsted_mi_github >}}){target="_blank"}</span>

- These slides and mini {targets} example GitHub: <span class="link-underlined">[Link]({{< env slides_github >}}){target="_blank"}</span>

- {sqltargets} GitHub: <span class="link-underlined">[Link]({{< env sql_targets_git >}}){target="_blank"}</span>

- Building reproducible analytical pipelines with R: <span class="link-underlined">[Link]({{< env bruno_targets >}}){target="_blank"}</span>

Email me at:

<span style = "color:#4758AB;">jake.tufts@education.gov.uk</span>

</section>

------------------------------------------------------------------------

## Example of a larger pipeline {.scrollable}

<br>

[Ofsted MI {targets} example pipeline GitHub]({{< env ofsted_mi_github >}}){target="_blank"}

![Process map](_images/ofsted-mi-process-map.jpg)

![Targets pipeline](_images/ofsted_targets_pipeline.png)



