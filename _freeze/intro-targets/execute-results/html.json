{
  "hash": "0408db0c7c7fe4dc1f01159a19886785",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"{targets} 🎯\"\ntitle-slide-attributes: \n  data-background-image: _images/targets_hex.png\n  data-background-size: 200px\n  data-background-position: center 90%\nsubtitle: \"An introduction to the package {`targets`}\"\nexecute: \n  echo: true\n  eval: false\nformat: \n  revealjs:\n    hash-type: number\n    code-line-numbers: true\n---\n\n\n------------------------------------------------------------------------\n\n## <span style = \"color:#4758AB;\">{targets}</span> is a pipeline tool\n\n<section class=\"center\">\n\nUse it to coordinate your data analysis projects - TEST\n\n🧑‍💻\n\n</section>\n\n------------------------------------------------------------------------\n\n::: center\n## Why use <span style = \"color:#4758AB;\">{targets}</span>?\n\n🎯\n:::\n\n------------------------------------------------------------------------\n\n## Data analysis can be slow and repetitive {autoslide=\"1000\"}\n\n::: r-stack\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: launch-1\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    node [shape = box style=rounded color=transparent]\n    edge [color=transparent]\n    {\n        A[label=\"Launch the code\" color=black]\n        B[label=\"Wait while it runs\" fontcolor=transparent]\n        C[label=\"Discover an issue\" fontcolor=transparent]\n        D[label=\"Restart from scratch\" fontcolor=transparent]\n    }\n    A -> B [color=transparent]\n    A -> D [dir=back color=transparent]\n    B -> C [color=transparent]\n    D -> C [dir=back color=transparent]\n}\n```\n\n:::\n\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: wait-1\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    node [shape = box style=rounded color=transparent]\n    edge [color=transparent]\n    {\n        A[label=\"Launch the code\" color=black]\n        B[label=\"Wait while it runs\" color=black]\n        C[label=\"Discover an issue\" fontcolor=transparent]\n        D[label=\"Restart from scratch\" fontcolor=transparent]\n    }\n    A -> B [color=black]\n    A -> D [dir=back color=transparent]\n    B -> C [color=transparent]\n    D -> C [dir=back color=transparent]\n}\n```\n\n:::\n\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: discover-1\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    node [shape = box style=rounded color=transparent]\n    edge [color=transparent]\n    {\n        A[label=\"Launch the code\" color=black]\n        B[label=\"Wait while it runs\" color=black]\n        C[label=\"Discover an issue\" color=black]\n        D[label=\"Restart from scratch\" fontcolor=transparent]\n    }\n    A -> B [color=black]\n    A -> D [dir=back color=transparent]\n    B -> C [color=black]\n    D -> C [dir=back color=transparent]\n}\n```\n\n:::\n\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: restart-1\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    node [shape = box style=rounded color=transparent]\n    edge [color=transparent]\n    {\n        A[label=\"Launch the code\" color=black]\n        B[label=\"Wait while it runs\" color=black]\n        C[label=\"Discover an issue\" color=black]\n        D[label=\"Restart from scratch\" color=black]\n    }\n    A -> B [color=black]\n    A -> D [dir=back color=transparent]\n    B -> C [color=black]\n    D -> C [dir=back color=black]\n}\n```\n\n:::\n\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: full-1\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    {\n    node [shape = box style=rounded]\n        A[label=\"Launch the code\"]\n        B[label=\"Wait while it runs\"]\n        C[label=\"Discover an issue\"]\n        D[label=\"Restart from scratch\"]\n    }\n    A -> B\n    A -> D [dir=back]\n    B -> C\n    D -> C [dir=back]\n}\n```\n\n:::\n\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: launch-2\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    node [shape = box style=rounded color=transparent]\n    edge [color=transparent]\n    {\n        A[label=\"Launch the code\" color=black]\n        B[label=\"Wait while it runs\" fontcolor=transparent]\n        C[label=\"Discover an issue\" fontcolor=transparent]\n        D[label=\"Restart from scratch\" fontcolor=transparent]\n    }\n    A -> B [color=transparent]\n    A -> D [dir=back color=transparent]\n    B -> C [color=transparent]\n    D -> C [dir=back color=transparent]\n}\n```\n\n:::\n\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: wait-2\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    node [shape = box style=rounded color=transparent]\n    edge [color=transparent]\n    {\n        A[label=\"Launch the code\" color=black]\n        B[label=\"Wait while it runs\" color=black]\n        C[label=\"Discover an issue\" fontcolor=transparent]\n        D[label=\"Restart from scratch\" fontcolor=transparent]\n    }\n    A -> B [color=black]\n    A -> D [dir=back color=transparent]\n    B -> C [color=transparent]\n    D -> C [dir=back color=transparent]\n}\n```\n\n:::\n\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: discover-2\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    node [shape = box style=rounded color=transparent]\n    edge [color=transparent]\n    {\n        A[label=\"Launch the code\" color=black]\n        B[label=\"Wait while it runs\" color=black]\n        C[label=\"Discover an issue\" color=black]\n        D[label=\"Restart from scratch\" fontcolor=transparent]\n    }\n    A -> B [color=black]\n    A -> D [dir=back color=transparent]\n    B -> C [color=black]\n    D -> C [dir=back color=transparent]\n}\n```\n\n:::\n\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: restart-2\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    node [shape = box style=rounded color=transparent]\n    edge [color=transparent]\n    {\n        A[label=\"Launch the code\" color=black]\n        B[label=\"Wait while it runs\" color=black]\n        C[label=\"Discover an issue\" color=black]\n        D[label=\"Restart from scratch\" color=black]\n    }\n    A -> B [color=black]\n    A -> D [dir=back color=transparent]\n    B -> C [color=black]\n    D -> C [dir=back color=black]\n}\n```\n\n:::\n\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: full-2\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    {\n    node [shape = box style=rounded]\n        A[label=\"Launch the code\"]\n        B[label=\"Wait while it runs\"]\n        C[label=\"Discover an issue\"]\n        D[label=\"Restart from scratch\"]\n    }\n    A -> B\n    A -> D [dir=back]\n    B -> C\n    D -> C [dir=back]\n}\n```\n\n:::\n\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: launch-3\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    node [shape = box style=rounded color=transparent]\n    edge [color=transparent]\n    {\n        A[label=\"Launch the code\" color=black]\n        B[label=\"Wait while it runs\" fontcolor=transparent]\n        C[label=\"Discover an issue\" fontcolor=transparent]\n        D[label=\"Restart from scratch\" fontcolor=transparent]\n    }\n    A -> B [color=transparent]\n    A -> D [dir=back color=transparent]\n    B -> C [color=transparent]\n    D -> C [dir=back color=transparent]\n}\n```\n\n:::\n:::\n\n------------------------------------------------------------------------\n\n## How does <span style = \"color:#4758AB;\">{targets}</span> combat this?\n\n<section class=\"left-align\">\n\n<br><br>\n\n::: left\n::: fragment\n1.  Skips unchanged code/ steps 🏃\n:::\n\n::: fragment\n2.  Evidence that `code = results` 🔬\n:::\n\n::: fragment\n3.  Produces code dependency graphs 🦾\n:::\n\n::: fragment\n4.  Makes parallel computing easy 🔀\n:::\n:::\n\n</section>\n\n::: notes\n-   Watches the workflow and skips steps (targets) whose code,\ndata & upstream dependencies have not changed.\n-   When all targets are up to date,\nevidence that results match the code.\n    -   Trust results.\n    -   Confirm computation is reproducible\n:::\n\n------------------------------------------------------------------------\n\n<section class=\"center\">\n\n\"{`targets`} implicitly nudges users toward a clean,\nfunction-oriented programming style that fits the intent of the\nR language\"\n\n</section>\n\n------------------------------------------------------------------------\n\n## Setup\n\n<br><br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"targets\")\n```\n:::\n\n\n------------------------------------------------------------------------\n\n## Create an R project\n\n<br><br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::create_project(path = r\"(C:\\Users\\jtufts\\Documents\\targets-demo)\")\n```\n:::\n\n\n<br>\n\n::: callout-tip\n<section style=\"text-align: left;\">\n\nQuick plug that you can use my package to create a\npre-populated R project directory!\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndauRtemplate::dau_proj_template(path = r\"(C:\\Users\\jtufts\\Documents\\targets-demo)\")\n```\n:::\n\n\n<br>\n\nMore information here:\n<span class=\"link-underlined\">[https://github.com/JT-39/dau-R-template-ext]({{< env url_dauR_template >}}){target=\"_blank\"}</span>\n\n</section>\n:::\n\n------------------------------------------------------------------------\n\n## Develop your data pipeline\n\n<br><br>\n\nThe project directory could look something like...\n\n<br>\n\n``` {.bash .code code-line-numbers=\"false\"}\n├── analysis.R\n├── _data/\n│   ├── raw_data.csv\n├── R/\n│   ├── functions.R\n```\n\n------------------------------------------------------------------------\n\n## Absence data\n\n<br>\n\n![](_images/absence_data.png){style=\"border: 2px solid grey;\"}\n\n------------------------------------------------------------------------\n\n## analysis.R\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(here::here(\"src/R/functions.R\"))\n\n# Path to absence data\nabsence_data_file_path <- here::here(\"_data/raw/1_absence_3term_nat_reg_la.csv\")\n\n# Extract national absence and format date\ndf_nat_absence <- get_nat_absence_data(absence_data_file_path) |>\n  format_time_period()\n\n# Fit a linear model\nmodel <- fit_model(df_nat_absence)\n\n# Plot the data and model\nplot_model(model, df_nat_absence)\n```\n:::\n\n\n------------------------------------------------------------------------\n\n## functions.R\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Pull national absence from file\nget_nat_absence_data <- function(file_path) {\n  read.csv(file = file_path) |>\n    dplyr::filter(geographic_level == \"National\")\n}\n\n# Extract the start year from academic year\nextract_year <- function(date) {\n  paste0(substr(date, 1, 4))\n}\n\n# Format the year as a date\nformat_time_period <- function(data) {\n  data |>\n    dplyr::mutate(Date = lubridate::year(as.Date(extract_year(time_period),\n                                                 format = \"%Y\")),\n                  .after=time_period)\n}\n\n\n# Fit the model and pull coefficients\nfit_model <- function(data) {\n  lm(sess_overall_percent_pa_10_exact ~ Date, data) |>\n    coefficients()\n}\n\n# Round to the nearets multiple of five\nround_to_multiple_five <- function(x) {\n  ceiling((x + 1)/5)*5\n}\n\n# Plot the data and model\nplot_model <- function(model, data) {\n  ggplot2::ggplot(data) +\n    ggplot2::geom_point(ggplot2::aes(x = Date,\n                                     y = sess_overall_percent_pa_10_exact,\n                                     colour = school_type)) +\n    ggplot2::geom_line(ggplot2::aes(x = Date,\n                                     y = sess_overall_percent_pa_10_exact,\n                                     colour = school_type)) +\n    ggplot2::scale_colour_manual(values = kasstylesr::color_picker(4),\n                                 breaks = c(\"Total\", \"State-funded primary\",\n                                            \"State-funded secondary\", \"Special\")) +\n    ggplot2::geom_abline(intercept = model[1],\n                         slope = model[2],\n                         show.legend = T,\n                         colour=\"red\",\n                         linetype=\"dashed\") +\n    ggplot2::annotate(\"text\",\n                      x = max(data$Date),\n                      y = lm(sess_overall_percent_pa_10_exact ~ Date,\n                             df_nat_absence) |>\n                        fitted.values() |>\n                        max(),\n                      hjust = -0.45,\n                      label = \"Line of best fit\",\n                      colour = \"red\") +\n    ggplot2::scale_y_continuous(breaks = scales::pretty_breaks(),\n                                limits = function(x) {\n                                  c(0, round_to_multiple_five(max(x)))\n                                }) +\n    ggplot2::coord_cartesian(clip = 'off') +\n    ggplot2::theme_minimal() +\n    kasstylesr::kas_style() +\n    ggplot2::labs(\n      title = \"Average persistent absence over time in England\",\n      subtitle = \"Split by school type. Only includes persistent absentees.\",\n      x = \"\",\n      y = \"Overall absence rate (%)\",\n      colour = \"School type:\"\n    )\n}\n```\n:::\n\n\n------------------------------------------------------------------------\n\n## Now make a <span style = \"color:#4758AB;\">{targets}</span> pipeline\n\n<br><br>\n\n``` {.bash .code code-line-numbers=\"false\"}\n├── _targets_analysis.R*\n├── _data/\n│   ├── raw_data.csv\n├── R/\n│   ├── functions.R\n```\n\n------------------------------------------------------------------------\n\n## Create a <span style = \"color:#4758AB;\">{targets}</span> template\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntargets::tar_script()\n```\n:::\n\n\n<br>\n\n![](_images/tar_script.png){style=\"border: 2px solid grey;\"}\n\n------------------------------------------------------------------------\n\n## There are 3 parts to the pipeline\n\n<section class=\"left-align\">\n\n::: {.fragment .fade-in-then-semi-out}\n1.  Packages are loaded\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(targets)\n```\n:::\n\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n2.  Pipeline-specific options are set\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_option_set(packages = \"utils\")\ntar_source(here::here(\"R/functions.R\"))\n```\n:::\n\n:::\n\n::: {.fragment .fade-in}\n3.  The pipeline itself, a series of *targets*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist(\n  tar_target(name = data,\n             command = data.frame(x = sample.int(100),\n                                  y = sample.int(100))),\n  tar_target(name = data_summary,\n             command = summarize_data(data))\n)\n```\n:::\n\n:::\n\n</section>\n\n::: notes\n-   Due to the execution of the pipeline in parallel,\nload packages used in pipeline seperately.\n    -   So the pkgs are available to all workers.\n-   At the top of the script, think “pipeline infrastructure” packages\n({targets} and some others).\n-   Inside tar_option_set() think\n“functions that run inside the pipeline” packages.\n:::\n\n------------------------------------------------------------------------\n\n## The <span style = \"color:#4758AB;\">{targets}</span> pipeline\n\n<br><br>\n\n<section class=\"left-align\">\n\n::: {.fragment .fade-in-then-semi-out}\n-   It is simply a list of *targets* 🎯\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   A target is defined using `tar_target()`\n:::\n\n::: {.fragment .fade-in}\n-   Each has 2 necessary inputs\n    -   `name`\n    -   `command` \\~ the function that generates the target\n:::\n\n</section>\n\n------------------------------------------------------------------------\n\n## The <span style = \"color:#4758AB;\">{targets}</span> pipeline\n\n<br>\n\n<section class=\"left-align\">\n\n::: fragment\nSo... a target defined as:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_target(name = y, command = f(x))\n```\n:::\n\n:::\n\n<br>\n\n::: {.fragment .fade-in}\nCan be understood as:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- f(x)\n```\n:::\n\n:::\n\n<br>\n\n::: {.fragment .fade-in}\n-   Targets after this can use the output of previous targets\n:::\n\n</section>\n\n::: notes\n-   A target is really just a step in the analysis pipeline\n:::\n\n------------------------------------------------------------------------\n\n## The <span style = \"color:#4758AB;\">{targets}</span> pipeline\n\n<br>\n\n![](./_images/targets_pipeline.png){style=\"border: 2px solid grey;\"}\n\n------------------------------------------------------------------------\n\n## Build the pipeline\n\n<br><br>\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_make(script = \"src/_targets_analysis.R\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n> dispatched target data_file\no completed target data_file [3.21 seconds]\n> dispatched target nat_data\no completed target nat_data [0.63 seconds]\n> dispatched target nat_data_clean\no completed target nat_data_clean [0.01 seconds]\n> dispatched target model\no completed target model [0.01 seconds]\nSaving 7 x 7 in image\n> dispatched target plot\no completed target plot [7.87 seconds]\n> ended pipeline [12.12 seconds]\n```\n\n\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n## An empty global environment?\n\n<br>\n\n![](_images/empty_environment.png){style=\"border: 2px solid grey;\"}\n\n------------------------------------------------------------------------\n\n## What is going on?\n\n<br><br>\n\n<section class=\"left-align\">\n\n::: {.fragment .fade-in-then-semi-out}\n-   {`targets`} creates a pipeline of pure functions\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   Running the pipeline does not depend on the global environment 🌍\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   It also does not change anything outside its scope 🔭\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   The pipeline is **PURE**\n:::\n\n</section>\n\n------------------------------------------------------------------------\n\n## <span style = \"color:#4758AB;\">_targets/</span>\n\n<br><br>\n\n<section class=\"left-align\">\n\n::: {.fragment .fade-in-then-semi-out}\n-   The outputs are stored in `_targets/objects/`\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   Each target is saved as an object in the `.rds` format\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   So, you **MUST** add `_targets/` to `.gitignore`\n(for GitHub)\n☝️\n:::\n\n</section>\n\n------------------------------------------------------------------------\n\n## <span style = \"color:#4758AB;\">_targets/</span>\n\n<br>\n\n::: {.fragment .fade-in}\n\n```{.bash .code code-line-numbers=\"false\"}\n_targets/\n├── meta\n│   ├── meta\n│   ├── process\n│   └── progress\n├── objects\n│   ├── model\n│   ├── nat_data\n│   └── nat_data_clean\n└── user\n```\n:::\n\n<br>\n\n::: {.fragment .fade-in-then}\n\n![](_images/_targets_objects.png){style=\"border: 2px solid grey;\"}\n:::\n\n------------------------------------------------------------------------\n\n## <span style = \"color:#4758AB;\">_targets/</span>\n\n<br>\n\n<section class=\"left-align\">\n\n::: {.fragment .fade-in-then-out}\nTo display targets:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_read(model)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(Intercept)        Date \n3153.093497   -1.549805 \n```\n\n\n:::\n:::\n\n:::\n\n<br>\n\n::: {.fragment .fade-in-then-out}\nTo load targets into the global environment:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_load(model)\n```\n:::\n\n:::\n\n</section>\n\n::: notes\n-   Well not strictly pure...\n-   `.rds` is a R-specific format to save *any* type of object\n-   Can be save and read with `saveRDS()` and `readRDS()`\n-   Also should note that the pipeline is composition of pure functions.\n-   Pure functions:\n    -   Referentially transparent function is a function that does not\n    use any variable that is not also one of its inputs.\n    -   A function that does not interact in any way with the\n    global environment.\n-   Functions with only side-effects will be difficult to handle.\nFor example, `base::plot()`\n:::\n\n------------------------------------------------------------------------\n\n## Handling files\n\n<br>\n\n::: {.callout-warning title=\"Advanced\"}\n<section class=\"left-align\">\n\n::: {.fragment .fade-in}\n-   **MUST** use the data's file path initially (and `format = \"file\"`)\n:::\n\n::: {.fragment .fade-in}\n\n::: {.cell}\n\n```{.r .cell-code}\ntargets::tar_target(\n    name = data,\n    command = here::here(\"_data/raw/1_absence_3term_nat_reg_la.csv\"),\n    format = \"file\"\n)\n```\n:::\n\n:::\n\n::: {.fragment .fade-in}\n-   Then use the file path target to read in the data\n:::\n\n::: {.fragment .fade-in}\n\n::: {.cell}\n\n```{.r .cell-code}\ntargets::tar_target(\n    name = nat_data,\n    command = read.csv(data)\n)\n```\n:::\n\n:::\n\n::: {.fragment .fade-in}\n-   Otherwise, {`targets`} will not track the data (any changes to it)\n:::\n\n</section>\n:::\n\n------------------------------------------------------------------------\n\n## File Big Brother\n\n<br><br>\n\n<section class=\"left-align\">\n\n::: {.fragment .fade-in-then-semi-out}\n-   {`targets`} keeps track of changes in files and functions 🕵️\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   Any changes will result in the targets being identified as out-of-date\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   So, are re-computed (and their dependencies)\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   We can visualise this...\n:::\n\n</section>\n\n------------------------------------------------------------------------\n\n## Code dependency graph\n\n<br> ![](./_images/complete_code_dependency_graph.png){style=\"border: 2px solid grey;\"}\n\n------------------------------------------------------------------------\n\n## Let's change something\n\n<br><br>\n\n<section style=\"text-align: left;\">\n\n::: {.fragment .fade-in}\n-   We now filter out the years 2020 & 2021\n\n\n::: {.cell}\n\n```{.r .cell-code}\nformat_time_period <- function(data) {\n  data |>\n    ... |>\n    dplyr::filter(Date %in% c(2020, 2021))\n}\n```\n:::\n\n:::\n\n</section>\n\n------------------------------------------------------------------------\n\n## Let's change something\n\n<br>\n\n::: {.fragment .fade-in width=\"450\" height=\"300\"}\n![](./_images/incomplete_code_dependency_graph.png){style=\"border: 2px solid grey;\"}\n:::\n\n::: notes\n-   The graph will also highlight in red if there is an\nerror in the pipeline.\n:::\n\n------------------------------------------------------------------------\n\n## Parallel computation\n\n<br>\n\n<section class=\"left-align\">\n\n::: {.fragment .fade-in-then-semi-out}\n-   Can run any independent steps (*targets*) in parallel 🔀\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   We are able to harness any GPU cores available, cutting computation time ✂️\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   {`targets`} knows which parts of the pipeline can be ran in parallel\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   To set this up...\n:::\n\n</section>\n\n::: notes\n-   Also could be useful on DataBricks where more cores and\nnodes may be available.\n:::\n\n------------------------------------------------------------------------\n\n## Parallel computation\n\n<br>\n\n<section class=\"left-align\">\n\n::: {.fragment .fade-in-then-out}\nNeed to load a few more packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(targets)\nlibrary(future)\nlibrary(future.callr)\nplan(callr)\n```\n:::\n\n:::\n\n::: {.fragment .fade-in-then-out}\nUtilise the {`targets`} function to run in parallel:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set workers = 2 to use 2 cpu cores\ntargets::tar_make_future(workers = 2)\n```\n:::\n\n:::\n\n::: {.fragment .fade-in}\nSimple as that! 💥\n:::\n\n</section>\n\n::: notes\n-   Most of our laptops have around 7 cores.\n-   Don't use all the cores though as some are needed for\nbackground computer stuff!\n:::\n\n------------------------------------------------------------------------\n\n::: center\n## Other features\n\n🔮\n:::\n\n------------------------------------------------------------------------\n\n## RMarkdown & Quarto\n\n<br>\n\n<section style=\"text-align: left;\">\n\n::: {.fragment .fade-in-then-semi-out}\n-   Can include the rendering of a `.Rmd` or `.qmd` to the pipeline\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   Utilises the power of the {`targets`} computation 🔋\n:::\n\n<br>\n\n::: r-stack\n::: {.fragment .fade-in-then-out}\nLoad package needed\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibray(tarchetypes)\n```\n:::\n\n:::\n\n::: {.fragment .fade-in-then-out}\nFunction to render Quarto file in the pipeline\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_render(\n  my_doc,\n  \"my_document.qmd\"\n)\n```\n:::\n\n:::\n\n::: {.fragment .fade-in-then-out}\nHow to load targets in the Quarto file\n\n```{{r}}\ntar_read(plot)\n```\n:::\n:::\n\n</section>\n\n------------------------------------------------------------------------\n\n## SQL\n\n<section class=\"left-align\">\n\n::: {.fragment .fade-in-then-out}\n-   When executing code to SQL you will need to create\nconnect and disconnect each time 🔌\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunction(yml_key) {\n  conn <- connect_sql_db(yml_key)\n  on.exit(DBI::dbDisconnect(conn, shutdown = TRUE))\n\n  DBI::dbGetQuery(...)}\n```\n:::\n\n:::\n\n::: {.fragment .fade-in}\n-   Also the package {`sqltargets`} which applies {`targets`}\nprinciples to .sql files 📦\n:::\n\n::: r-stack\n::: {.fragment .fade-in-then-out}\n\n::: {.cell}\n\n```{.sql .cell-code}\n-- !preview conn=DBI::dbConnect(RSQLite::SQLite())\n-- tar_load(query_params)\nselect id\nfrom table\nwhere age > {age_threshold}\n```\n:::\n\n:::\n\n::: {.fragment .fade-in}\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_sql(query, path = \"query.sql\", query_params = query_params)\n```\n:::\n\n:::\n:::\n\n</section>\n\n::: notes\n-   SQL connection repetitio is to ensure the connection is\nclosed and is reusable\n:::\n\n------------------------------------------------------------------------\n\n## Key takeaways\n\n<br><br>\n\n<section class=\"left-align\">\n\n::: {.fragment .fade-in-then-semi-out}\n-   Enforces a modular, function based pipelines ✅ <br>(R best practice!)\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   Tracks changes to datasets and functions 🔍\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   Provides efficient computation of pipelines ♻️\n:::\n\n</section>\n\n------------------------------------------------------------------------\n\n::: center\n## We've hit the target!\n\n🎯\n:::\n\n------------------------------------------------------------------------\n\n## Resources, links and email\n\n<br>\n\n<section class=\"left-align\">\n\n-   {targets} manual: <span class=\"link-underlined\">[Link]({{< env targets_pkg_manual >}}){target=\"_blank\"}</span>\n\n-   YouTube {targets} walkthrough: <span class=\"link-underlined\">[Link]({{< env youtube_targets >}}){target=\"_blank\"}</span>\n\n-   Ofsted MI {targets} example pipeline GitHub: <span class=\"link-underlined\">[Link]({{< env ofsted_mi_github >}}){target=\"_blank\"}</span>\n\n-   These slides and mini {targets} example GitHub: <span class=\"link-underlined\">[Link]({{< env slides_github >}}){target=\"_blank\"}</span>\n\n-   {sqltargets} GitHub: <span class=\"link-underlined\">[Link]({{< env sql_targets_git >}}){target=\"_blank\"}</span>\n\nEmail me at:\n\n<span style = \"color:#4758AB;\">jake.tufts@education.gov.uk</span>\n\n</section>\n",
    "supporting": [
      "intro-targets_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}