{
  "hash": "e67e0ea9506e97f4d25002e4ef2d73e7",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"{targets} 🎯\"\ntitle-slide-attributes: \n  data-background-image: _images/targets_hex.png\n  data-background-size: 200px\n  data-background-position: center 90%\nsubtitle: \"An introduction to the package `{targets}`\"\nexecute: \n  echo: true\n  eval: false\nformat: \n  revealjs:\n    hash-type: number\n    code-line-numbers: true\n---\n\n\n------------------------------------------------------------------------\n\n## `{targets}` is a pipeline tool\n\n<section class=\"center\">\n\nUse it to coordinate your data analysis projects.\n</section>\n\n------------------------------------------------------------------------\n\n<div class=\"center\">\n\n## Why use `{targets}`?\n</div>\n\n------------------------------------------------------------------------\n\n## Data analysis can be slow and repetitive {autoslide=\"1000\"}\n\n::: r-stack\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: launch-1\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    node [shape = box style=rounded color=transparent]\n    edge [color=transparent]\n    {\n        A[label=\"Launch the code\" color=black]\n        B[label=\"Wait while it runs\" fontcolor=transparent]\n        C[label=\"Discover an issue\" fontcolor=transparent]\n        D[label=\"Restart from scratch\" fontcolor=transparent]\n    }\n    A -> B [color=transparent]\n    A -> D [dir=back color=transparent]\n    B -> C [color=transparent]\n    D -> C [dir=back color=transparent]\n}\n```\n\n:::\n\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: wait-1\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    node [shape = box style=rounded color=transparent]\n    edge [color=transparent]\n    {\n        A[label=\"Launch the code\" color=black]\n        B[label=\"Wait while it runs\" color=black]\n        C[label=\"Discover an issue\" fontcolor=transparent]\n        D[label=\"Restart from scratch\" fontcolor=transparent]\n    }\n    A -> B [color=black]\n    A -> D [dir=back color=transparent]\n    B -> C [color=transparent]\n    D -> C [dir=back color=transparent]\n}\n```\n\n:::\n\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: discover-1\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    node [shape = box style=rounded color=transparent]\n    edge [color=transparent]\n    {\n        A[label=\"Launch the code\" color=black]\n        B[label=\"Wait while it runs\" color=black]\n        C[label=\"Discover an issue\" color=black]\n        D[label=\"Restart from scratch\" fontcolor=transparent]\n    }\n    A -> B [color=black]\n    A -> D [dir=back color=transparent]\n    B -> C [color=black]\n    D -> C [dir=back color=transparent]\n}\n```\n\n:::\n\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: restart-1\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    node [shape = box style=rounded color=transparent]\n    edge [color=transparent]\n    {\n        A[label=\"Launch the code\" color=black]\n        B[label=\"Wait while it runs\" color=black]\n        C[label=\"Discover an issue\" color=black]\n        D[label=\"Restart from scratch\" color=black]\n    }\n    A -> B [color=black]\n    A -> D [dir=back color=transparent]\n    B -> C [color=black]\n    D -> C [dir=back color=black]\n}\n```\n\n:::\n\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: full-1\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    {\n    node [shape = box style=rounded]\n        A[label=\"Launch the code\"]\n        B[label=\"Wait while it runs\"]\n        C[label=\"Discover an issue\"]\n        D[label=\"Restart from scratch\"]\n    }\n    A -> B\n    A -> D [dir=back]\n    B -> C\n    D -> C [dir=back]\n}\n```\n\n:::\n\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: launch-2\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    node [shape = box style=rounded color=transparent]\n    edge [color=transparent]\n    {\n        A[label=\"Launch the code\" color=black]\n        B[label=\"Wait while it runs\" fontcolor=transparent]\n        C[label=\"Discover an issue\" fontcolor=transparent]\n        D[label=\"Restart from scratch\" fontcolor=transparent]\n    }\n    A -> B [color=transparent]\n    A -> D [dir=back color=transparent]\n    B -> C [color=transparent]\n    D -> C [dir=back color=transparent]\n}\n```\n\n:::\n\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: wait-2\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    node [shape = box style=rounded color=transparent]\n    edge [color=transparent]\n    {\n        A[label=\"Launch the code\" color=black]\n        B[label=\"Wait while it runs\" color=black]\n        C[label=\"Discover an issue\" fontcolor=transparent]\n        D[label=\"Restart from scratch\" fontcolor=transparent]\n    }\n    A -> B [color=black]\n    A -> D [dir=back color=transparent]\n    B -> C [color=transparent]\n    D -> C [dir=back color=transparent]\n}\n```\n\n:::\n\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: discover-2\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    node [shape = box style=rounded color=transparent]\n    edge [color=transparent]\n    {\n        A[label=\"Launch the code\" color=black]\n        B[label=\"Wait while it runs\" color=black]\n        C[label=\"Discover an issue\" color=black]\n        D[label=\"Restart from scratch\" fontcolor=transparent]\n    }\n    A -> B [color=black]\n    A -> D [dir=back color=transparent]\n    B -> C [color=black]\n    D -> C [dir=back color=transparent]\n}\n```\n\n:::\n\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: restart-2\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    node [shape = box style=rounded color=transparent]\n    edge [color=transparent]\n    {\n        A[label=\"Launch the code\" color=black]\n        B[label=\"Wait while it runs\" color=black]\n        C[label=\"Discover an issue\" color=black]\n        D[label=\"Restart from scratch\" color=black]\n    }\n    A -> B [color=black]\n    A -> D [dir=back color=transparent]\n    B -> C [color=black]\n    D -> C [dir=back color=black]\n}\n```\n\n:::\n\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: full-2\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    {\n    node [shape = box style=rounded]\n        A[label=\"Launch the code\"]\n        B[label=\"Wait while it runs\"]\n        C[label=\"Discover an issue\"]\n        D[label=\"Restart from scratch\"]\n    }\n    A -> B\n    A -> D [dir=back]\n    B -> C\n    D -> C [dir=back]\n}\n```\n\n:::\n\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: launch-3\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    node [shape = box style=rounded color=transparent]\n    edge [color=transparent]\n    {\n        A[label=\"Launch the code\" color=black]\n        B[label=\"Wait while it runs\" fontcolor=transparent]\n        C[label=\"Discover an issue\" fontcolor=transparent]\n        D[label=\"Restart from scratch\" fontcolor=transparent]\n    }\n    A -> B [color=transparent]\n    A -> D [dir=back color=transparent]\n    B -> C [color=transparent]\n    D -> C [dir=back color=transparent]\n}\n```\n\n:::\n:::\n\n------------------------------------------------------------------------\n\n## How does `{targets}` combat this?\n\n<section class=\"left-align\">\n\n<br><br>\n\n::: left\n::: fragment\n1.  Skips unchanged code/ steps 🏃\n:::\n\n::: fragment\n2.  Evidence that `code = results` 🔬\n:::\n\n::: fragment\n3.  Produces code dependency graphs 🦾\n:::\n\n::: fragment\n4.  Makes parallel computing easy 🔀\n:::\n:::\n\n</section>\n\n::: notes\n- Watches the workflow and skips steps (targets) whose code,\ndata & upstream dependencies have not changed.\n- When all targets are up to date, evidence that results match the code.\n    -   Trust results.\n    -   Confirm computation is reproducible\n:::\n\n------------------------------------------------------------------------\n\n<section class=\"center\">\n\n\"`{targets}` implicitly nudges users toward a clean,\nfunction-oriented programming style that fits the intent of the\nR language\"\n</section>\n\n------------------------------------------------------------------------\n\n## Setup\n\n<br><br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"targets\")\n```\n:::\n\n\n------------------------------------------------------------------------\n\n## Create an R project\n\n<br><br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::create_project(path = r\"(C:\\Users\\jtufts\\Documents\\targets-demo)\")\n```\n:::\n\n\n<br>\n\n::: {.callout-tip}\n<section style=\"text-align: left;\">\n\nQuick plug that you can use my package to create a pre-populated\nR project directory!\n\n::: {.cell}\n\n```{.r .cell-code}\ndauRtemplate::dau_proj_template(path = r\"(C:\\Users\\jtufts\\Documents\\targets-demo)\")\n```\n:::\n\n\n<br>\n\nMore information here:\n[https://github.com/JT-39/dau-R-template-ext]({{< env url_dauR_template >}}){target=\"_blank\"}\n</section>\n\n:::\n\n------------------------------------------------------------------------\n\n## Develop your data pipeline\n\n<br><br>\n\nThe project directory could look something like...\n\n<br>\n\n```{.bash .code code-line-numbers=\"false\"}\n├── analysis.R\n├── _data/\n│   ├── raw_data.csv\n├── R/\n│   ├── functions.R\n```\n\n------------------------------------------------------------------------\n\n## Absence data\n\n<br>\n\n![](_images/absence_data.png){style=\"border: 2px solid grey;\"}\n\n------------------------------------------------------------------------\n\n## analysis.R\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(here::here(\"src/R/functions.R\"))\n\n# Path to absence data\nabsence_data_file_path <- here::here(\"_data/raw/1_absence_3term_nat_reg_la.csv\")\n\n# Extract national absence and format date\ndf_nat_absence <- get_nat_absence_data(absence_data_file_path) |>\n  format_time_period()\n\n# Fit a linear model\nmodel <- fit_model(df_nat_absence)\n\n# Plot the data and model\nplot_model(model, df_nat_absence)\n```\n:::\n\n\n------------------------------------------------------------------------\n\n## functions.R\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Pull national absence from file\nget_nat_absence_data <- function(file_path) {\n  read.csv(file = file_path) |>\n    dplyr::filter(geographic_level == \"National\")\n}\n\n# Extract the start year from academic year\nextract_year <- function(date) {\n  paste0(substr(date, 1, 4))\n}\n\n# Format the year as a date\nformat_time_period <- function(data) {\n  data |>\n    dplyr::mutate(Date = lubridate::year(as.Date(extract_year(time_period),\n                                                 format = \"%Y\")),\n                  .after=time_period)\n}\n\n\n# Fit the model and pull coefficients\nfit_model <- function(data) {\n  lm(sess_overall_percent_pa_10_exact ~ Date, data) |>\n    coefficients()\n}\n\n# Round to the nearets multiple of five\nround_to_multiple_five <- function(x) {\n  ceiling((x + 1)/5)*5\n}\n\n# Plot the data and model\nplot_model <- function(model, data) {\n  ggplot2::ggplot(data) +\n    ggplot2::geom_point(ggplot2::aes(x = Date,\n                                     y = sess_overall_percent_pa_10_exact,\n                                     colour = school_type)) +\n    ggplot2::geom_line(ggplot2::aes(x = Date,\n                                     y = sess_overall_percent_pa_10_exact,\n                                     colour = school_type)) +\n    ggplot2::scale_colour_manual(values = kasstylesr::color_picker(4),\n                                 breaks = c(\"Total\", \"State-funded primary\",\n                                            \"State-funded secondary\", \"Special\")) +\n    ggplot2::geom_abline(intercept = model[1],\n                         slope = model[2],\n                         show.legend = T,\n                         colour=\"red\",\n                         linetype=\"dashed\") +\n    ggplot2::annotate(\"text\",\n                      x = max(data$Date),\n                      y = lm(sess_overall_percent_pa_10_exact ~ Date,\n                             df_nat_absence) |>\n                        fitted.values() |>\n                        max(),\n                      hjust = -0.45,\n                      label = \"Line of best fit\",\n                      colour = \"red\") +\n    ggplot2::scale_y_continuous(breaks = scales::pretty_breaks(),\n                                limits = function(x) {\n                                  c(0, round_to_multiple_five(max(x)))\n                                }) +\n    ggplot2::coord_cartesian(clip = 'off') +\n    ggplot2::theme_minimal() +\n    kasstylesr::kas_style() +\n    ggplot2::labs(\n      title = \"Average persistent absence over time in England\",\n      subtitle = \"Split by school type. Only includes persistent absentees.\",\n      x = \"\",\n      y = \"Overall absence rate (%)\",\n      colour = \"School type:\"\n    )\n}\n```\n:::\n\n\n------------------------------------------------------------------------\n\n## Now make a `{targets}` pipeline\n\n<br><br>\n\n```{.bash .code code-line-numbers=\"false\"}\n├── _targets_analysis.R**\n├── _data/\n│   ├── raw_data.csv\n├── R/\n│   ├── functions.R\n```\n\n------------------------------------------------------------------------\n\n## Create a `{targets}` template\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntargets::tar_script()\n```\n:::\n\n\n<br>\n\n![](_images/tar_script.png){style=\"border: 2px solid grey;\"}\n\n------------------------------------------------------------------------\n\n## There are 3 parts to the pipeline\n\n<section class=\"left-align\">\n\n::: {.fragment .fade-in-then-semi-out}\n1.  Packages are loaded\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(targets)\n```\n:::\n\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n2.  Pipeline-specific options are set\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_option_set(packages = \"utils\")\ntar_source(here::here(\"R/functions.R\"))\n```\n:::\n\n:::\n\n::: {.fragment .fade-in}\n3.  The pipeline itself, a series of *targets*\n\n::: {.cell}\n\n```{.r .cell-code}\nlist(\n  tar_target(name = data,\n             command = data.frame(x = sample.int(100),\n                                  y = sample.int(100))),\n  tar_target(name = data_summary,\n             command = summarize_data(data))\n)\n```\n:::\n\n:::\n\n</section>\n\n::: notes\n- Due to the execution of the pipeline in parallel,\nload packages used in pipeline seperately.\n    - So the pkgs are available to all workers.\n- At the top of the script, think “pipeline infrastructure”\npackages ({targets} and some others).\n- Inside tar_option_set() think\n“functions that run inside the  ipeline” packages.\n:::\n\n------------------------------------------------------------------------\n\n## The `{targets}` pipeline\n\n<br><br>\n<section class=\"left-align\">\n\n::: {.fragment .fade-in-then-semi-out}\n- It is simply a list of *targets*\n:::\n::: {.fragment .fade-in-then-semi-out}\n- A target is defined using `tar_target()`\n:::\n::: {.fragment .fade-in}\n- Each has 2 necessary inputs\n    - `name`\n    - `command` ~ the function that generates the target\n:::\n\n</section>\n\n------------------------------------------------------------------------\n\n## The `{targets}` pipeline\n\n<br>\n\n<section class=\"left-align\">\n\n::: {.fragment}\nSo... a target defined as:\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_target(name = y, command = f(x))\n```\n:::\n\n:::\n<br>\n\n::: {.fragment .fade-in}\nCan be understood as:\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- f(x)\n```\n:::\n\n:::\n<br>\n\n::: {.fragment .fade-in}\n- Targets after this can use the output of previous targets\n:::\n\n</section>\n\n::: notes\n- A target is really just a step in the analysis pipeline\n:::\n\n------------------------------------------------------------------------\n\n## The `{targets}` pipeline\n\n<br>\n\n![](./_images/targets_pipeline.png){style=\"border: 2px solid grey;\"}\n\n------------------------------------------------------------------------\n\n## Build the pipeline\n\n<br><br>\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_make(script = \"src/_targets_analysis.R\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n> dispatched target data_file\no completed target data_file [0.56 seconds]\n> dispatched target nat_data\no completed target nat_data [0.47 seconds]\n> dispatched target nat_data_clean\no completed target nat_data_clean [0.01 seconds]\n> dispatched target model\no completed target model [0 seconds]\n> dispatched target plot\nSaving 7 x 7 in image\no completed target plot [0.72 seconds]\n> ended pipeline [4.31 seconds]\n```\n\n\n:::\n:::\n\n\n-----------------------------------------------------------------------\n\n## An empty global environment?\n\n<br>\n\n![](_images/empty_environment.png){style=\"border: 2px solid grey;\"}\n\n------------------------------------------------------------------------\n\n## What is going on?\n\n<br><br>\n\n<section class=\"left-align\">\n::: {.fragment .fade-in-then-semi-out}\n- `{targets}` creates a pipeline of pure functions\n:::\n::: {.fragment .fade-in-then-semi-out}\n- Running the pipeline does not depend on the global environment\n:::\n::: {.fragment .fade-in-then-semi-out}\n- It also does not change anything outside its scope\n:::\n::: {.fragment .fade-in-then-semi-out}\n- The pipeline is **PURE**\n:::\n</section>\n\n------------------------------------------------------------------------\n\n## `_targets/`\n\n<br><br>\n\n<section class=\"left-align\">\n::: {.fragment .fade-in-then-semi-out}\n- The outputs are stored in `_targets/objects/`\n:::\n::: {.fragment .fade-in-then-semi-out}\n- Each target is saved as in the `.rds` format\n:::\n::: {.fragment .fade-in-then-semi-out}\n- So, **MUST** add `_targets/` to `.gitignore` (for GitHub)\n:::\n</section>\n\n------------------------------------------------------------------------\n\n## `_targets/`\n\n<br>\n<section class=\"left-align\">\n\n::: {.fragment .fade-in-then-out}\nTo read in targets:\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_read(model)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(Intercept)        Date \n3153.093497   -1.549805 \n```\n\n\n:::\n:::\n\n:::\n\n<br>\n\n::: {.fragment .fade-in-then-out}\nTo load targets into the global environment:\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_load(model)\n```\n:::\n\n:::\n\n</section>\n\n::: notes\n- Well not strictly pure...\n- `.rds` is a R-specific format to save *any* type of object\n- Can be save and read with `saveRDS()` and `readRDS()`\n- Also should note that the pipeline is composition of pure functions.\n- Pure functions:\n    - Referentially transparent function is a function that does\n    not use any variable that is not also one of its inputs.\n    - A function that does not interact in any way with the\n    global environment.\n- Functions with only side-effects will be difficult to handle.\nFor example, `base::plot()`\n:::\n------------------------------------------------------------------------\n\n## Handling files\n\n<br>\n\n::: {.callout-warning title=\"Advanced\"}\n<section class=\"left-align\">\n\n::: {.fragment .fade-in}\n- **MUST** use the data's file path initially (and `format` = \"file\")\n:::\n::: {.fragment .fade-in}\n\n::: {.cell}\n\n```{.r .cell-code}\ntargets::tar_target(\n    name = data,\n    command = here::here(\"_data/raw/1_absence_3term_nat_reg_la.csv\"),\n    format = \"file\"\n)\n```\n:::\n\n:::\n::: {.fragment .fade-in}\n- Then use the file path target to read in the data\n:::\n::: {.fragment .fade-in}\n\n::: {.cell}\n\n```{.r .cell-code}\ntargets::tar_target(\n    name = nat_data,\n    command = read.csv(data)\n)\n```\n:::\n\n:::\n::: {.fragment .fade-in}\n- Otherwise, `{targets}` will not track the data (any changes to it)\n:::\n\n</section>\n\n:::\n\n------------------------------------------------------------------------\n\n## File Big Brother\n\n<br><br>\n<section class=\"left-align\">\n::: {.fragment .fade-in-then-semi-out}\n- `{targets}` keeps track of changes in files and functions\n:::\n::: {.fragment .fade-in-then-semi-out}\n- Any changes will result in the targets being identified as out-of-date\n:::\n::: {.fragment .fade-in-then-semi-out}\n- So, are re-computed (and their dependencies)\n:::\n::: {.fragment .fade-in-then-semi-out}\n- We can visualise this...\n:::\n</section>\n\n------------------------------------------------------------------------\n\n## Code dependency graph\n\n<br>\n![](./_images/complete_code_dependency_graph.png){style=\"border: 2px solid grey;\"}\n\n------------------------------------------------------------------------\n\n## Let's change something\n\n<br><br>\n<section style=\"text-align: left;\">\n\n::: {.fragment .fade-in}\n- We now filter out the years 2020 & 2021\n\n::: {.cell}\n\n```{.r .cell-code}\nformat_time_period <- function(data) {\n  data |>\n    ... |>\n    dplyr::filter(Date %in% c(2020, 2021))\n}\n```\n:::\n\n:::\n\n</section>\n\n------------------------------------------------------------------------\n\n## Let's change something\n\n<br>\n\n::: {.fragment .fade-in width=\"450\" height=\"300\"}\n\n![](./_images/incomplete_code_dependency_graph.png){style=\"border: 2px solid grey;\"}\n:::\n\n------------------------------------------------------------------------\n\n## Parallel computation\n\n<br>\n<section class=\"left-align\">\n::: {.fragment .fade-in-then-semi-out}\n- Can run any indepedent steps (*targets*) in parallel\n:::\n::: {.fragment .fade-in-then-semi-out}\n- We are able to harness any GPU cores available,\ncutting computation time\n:::\n::: {.fragment .fade-in-then-semi-out}\n- `{targets}` knows which parts of the pipeline can be ran in parallel\n:::\n::: {.fragment .fade-in-then-semi-out}\n- To set this up...\n:::\n</section>\n\n::: notes\n- Also could be useful on DataBricks where more cores and nodes may\nbe available.\n:::\n\n------------------------------------------------------------------------\n\n## Parallel computation\n\n<br>\n<section class=\"left-align\">\n::: {.fragment .fade-in-then-out}\nNeed to load a few more packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(targets)\nlibrary(future)\nlibrary(future.callr)\nplan(callr)\n```\n:::\n\n:::\n::: {.fragment .fade-in-then-out}\nUtilise the `{targets}` function to run in parallel:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set workers = 2 to use 2 cpu cores\ntargets::tar_make_future(workers = 2)\n```\n:::\n\n:::\n::: {.fragment .fade-in}\nSimple as that!\n:::\n\n</section>\n\n::: notes\n- Most of our laptops have around 7 cores.\n- Don't use all the cores though as some are needed for background\ncomputer stuff!\n:::\n\n------------------------------------------------------------------------\n\n<div class=\"center\">\n\n## Other features\n</div>\n\n------------------------------------------------------------------------\n\n## RMarkdown & Quarto\n\n<br>\n<section style=\"text-align: left;\">\n::: {.fragment .fade-in-then-semi-out}\n- Can include the rendering of a `.Rmd` or `.qmd` to the pipeline\n:::\n::: {.fragment .fade-in-then-semi-out}\n- Utilises the power of the `{targets}` computation\n:::\n\n<br>\n\n::: r-stack\n::: {.fragment .fade-in-then-out}\nLoad package needed\n\n::: {.cell}\n\n```{.r .cell-code}\nlibray(tarchetypes)\n```\n:::\n\n:::\n::: {.fragment .fade-in-then-out}\nFunction to render Quarto file in the pipeline\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_render(\n  my_doc,\n  \"my_document.qmd\"\n)\n```\n:::\n\n:::\n::: {.fragment .fade-in-then-out}\nHow to load targets in the Quarto file\n```{{r}}\ntar_read(plot)\n```\n:::\n:::\n</section>\n\n------------------------------------------------------------------------\n\n## SQL\n\n\n------------------------------------------------------------------------\n\n## Key takeaways\n\n\n------------------------------------------------------------------------\n\n<div class=\"center\">\n\n## Thanks for hitting the target!\n</div>\n\n------------------------------------------------------------------------\n\n## Resources, links and email\n\n\n------------------------------------------------------------------------\n\n#### Code walkthrough\n\n<br> <br>\n\n### Scraping Ofsted MI data\n\n<br> <br> <br>\n\nSource code is available at\n[https://github.com/JT-39/]({{< env url_targets_git >}}){target=\"_blank\"}\n\n------------------------------------------------------------------------\n\n## Data pipeline\n\n<br>\n\n<section style=\"text-align: left;\">\n\n::: left\n::: fragment\n1.  Scrape Ofsted data 🍴\n:::\n\n::: fragment\n2.  Clean the data 🛁\n:::\n\n::: fragment\n3.  Upload to SQL 📤\n:::\n:::\n\n</section>\n\n------------------------------------------------------------------------\n\n## Process map\n\n![](_images/ofsted-mi-process-map.jpg)\n\n\n------------------------------------------------------------------------\n\n## {targets} code dependency graph\n\n",
    "supporting": [
      "intro-targets_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}