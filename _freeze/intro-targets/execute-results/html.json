{
  "hash": "5679991d074a92ef83f634a078a6ed97",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"{targets} 🎯\"\ntitle-slide-attributes: \n  data-background-image: _images/targets_hex.png\n  data-background-size: 200px\n  data-background-position: center 90%\nsubtitle: \"An introduction to the package {`targets`}\"\nexecute: \n  echo: true\n  eval: false\nformat: \n  revealjs:\n    hash-type: number\n    code-line-numbers: true\n---\n\n\n------------------------------------------------------------------------\n\n## [{targets}]{style=\"color:#4758AB;\"} is a pipeline tool\n\n<section class=\"center\">\n\nUse it to coordinate your data analysis projects\n\n🧑‍💻\n\n</section>\n\n------------------------------------------------------------------------\n\n## Why use [{targets}]{style=\"color:#4758AB;\"}? {.center}\n\n🎯\n\n------------------------------------------------------------------------\n\n<section class=\"center\">\n\n\"{`targets`} implicitly nudges users toward a clean, function-oriented programming style that fits the intent of the R language\"\n\n</section>\n\n------------------------------------------------------------------------\n\n## Data analysis can be slow and repetitive {autoslide=\"1000\"}\n\n::: r-stack\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: launch-1\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    node [shape = box style=rounded color=transparent]\n    edge [color=transparent]\n    {\n        A[label=\"Launch the code\" color=black]\n        B[label=\"Wait while it runs\" fontcolor=transparent]\n        C[label=\"Discover an issue\" fontcolor=transparent]\n        D[label=\"Restart from scratch\" fontcolor=transparent]\n    }\n    A -> B [color=transparent]\n    A -> D [dir=back color=transparent]\n    B -> C [color=transparent]\n    D -> C [dir=back color=transparent]\n}\n```\n\n:::\n\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: wait-1\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    node [shape = box style=rounded color=transparent]\n    edge [color=transparent]\n    {\n        A[label=\"Launch the code\" color=black]\n        B[label=\"Wait while it runs\" color=black]\n        C[label=\"Discover an issue\" fontcolor=transparent]\n        D[label=\"Restart from scratch\" fontcolor=transparent]\n    }\n    A -> B [color=black]\n    A -> D [dir=back color=transparent]\n    B -> C [color=transparent]\n    D -> C [dir=back color=transparent]\n}\n```\n\n:::\n\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: discover-1\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    node [shape = box style=rounded color=transparent]\n    edge [color=transparent]\n    {\n        A[label=\"Launch the code\" color=black]\n        B[label=\"Wait while it runs\" color=black]\n        C[label=\"Discover an issue\" color=black]\n        D[label=\"Restart from scratch\" fontcolor=transparent]\n    }\n    A -> B [color=black]\n    A -> D [dir=back color=transparent]\n    B -> C [color=black]\n    D -> C [dir=back color=transparent]\n}\n```\n\n:::\n\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: restart-1\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    node [shape = box style=rounded color=transparent]\n    edge [color=transparent]\n    {\n        A[label=\"Launch the code\" color=black]\n        B[label=\"Wait while it runs\" color=black]\n        C[label=\"Discover an issue\" color=black]\n        D[label=\"Restart from scratch\" color=black]\n    }\n    A -> B [color=black]\n    A -> D [dir=back color=transparent]\n    B -> C [color=black]\n    D -> C [dir=back color=black]\n}\n```\n\n:::\n\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: full-1\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    {\n    node [shape = box style=rounded]\n        A[label=\"Launch the code\"]\n        B[label=\"Wait while it runs\"]\n        C[label=\"Discover an issue\"]\n        D[label=\"Restart from scratch\"]\n    }\n    A -> B\n    A -> D [dir=back]\n    B -> C\n    D -> C [dir=back]\n}\n```\n\n:::\n\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: launch-2\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    node [shape = box style=rounded color=transparent]\n    edge [color=transparent]\n    {\n        A[label=\"Launch the code\" color=black]\n        B[label=\"Wait while it runs\" fontcolor=transparent]\n        C[label=\"Discover an issue\" fontcolor=transparent]\n        D[label=\"Restart from scratch\" fontcolor=transparent]\n    }\n    A -> B [color=transparent]\n    A -> D [dir=back color=transparent]\n    B -> C [color=transparent]\n    D -> C [dir=back color=transparent]\n}\n```\n\n:::\n\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: wait-2\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    node [shape = box style=rounded color=transparent]\n    edge [color=transparent]\n    {\n        A[label=\"Launch the code\" color=black]\n        B[label=\"Wait while it runs\" color=black]\n        C[label=\"Discover an issue\" fontcolor=transparent]\n        D[label=\"Restart from scratch\" fontcolor=transparent]\n    }\n    A -> B [color=black]\n    A -> D [dir=back color=transparent]\n    B -> C [color=transparent]\n    D -> C [dir=back color=transparent]\n}\n```\n\n:::\n\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: discover-2\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    node [shape = box style=rounded color=transparent]\n    edge [color=transparent]\n    {\n        A[label=\"Launch the code\" color=black]\n        B[label=\"Wait while it runs\" color=black]\n        C[label=\"Discover an issue\" color=black]\n        D[label=\"Restart from scratch\" fontcolor=transparent]\n    }\n    A -> B [color=black]\n    A -> D [dir=back color=transparent]\n    B -> C [color=black]\n    D -> C [dir=back color=transparent]\n}\n```\n\n:::\n\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: restart-2\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    node [shape = box style=rounded color=transparent]\n    edge [color=transparent]\n    {\n        A[label=\"Launch the code\" color=black]\n        B[label=\"Wait while it runs\" color=black]\n        C[label=\"Discover an issue\" color=black]\n        D[label=\"Restart from scratch\" color=black]\n    }\n    A -> B [color=black]\n    A -> D [dir=back color=transparent]\n    B -> C [color=black]\n    D -> C [dir=back color=black]\n}\n```\n\n:::\n\n::: {.fragment width=\"450\" height=\"300\"}\n\n```{dot}\n//| label: full-2\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    {\n    node [shape = box style=rounded]\n        A[label=\"Launch the code\"]\n        B[label=\"Wait while it runs\"]\n        C[label=\"Discover an issue\"]\n        D[label=\"Restart from scratch\"]\n    }\n    A -> B\n    A -> D [dir=back]\n    B -> C\n    D -> C [dir=back]\n}\n```\n\n:::\n:::\n\n------------------------------------------------------------------------\n\n## Data analysis can be slow and repetitive\n\n\n```{dot}\n//| label: full-end\n//| eval: true\n//| echo: false\n\ndigraph G {\n    rankdir=LR;\n    {\n    node [shape = box style=rounded]\n        A[label=\"Launch the code\"]\n        B[label=\"Wait while it runs\"]\n        C[label=\"Discover an issue\"]\n        D[label=\"Restart from scratch\"]\n    }\n    A -> B\n    A -> D [dir=back]\n    B -> C\n    D -> C [dir=back]\n}\n```\n\n\n------------------------------------------------------------------------\n\n## How does [{targets}]{style=\"color:#4758AB;\"} combat this?\n\n<section class=\"left-align\">\n\n<br><br>\n\n::: left\n::: fragment\n1.  Skips unchanged code/ steps 🏃\n:::\n\n::: fragment\n2.  Evidence that `code = results` 🔬\n:::\n\n::: fragment\n3.  Produces code dependency graphs 🦾\n:::\n\n::: fragment\n4.  Makes parallel computing easy 🔀\n:::\n:::\n\n</section>\n\n::: notes\n-   Watches the workflow and skips steps (targets) whose code, data & upstream dependencies have not changed.\n-   When all targets are up to date, evidence that results match the code.\n    -   Trust results.\n    -   Confirm computation is reproducible\n:::\n\n------------------------------------------------------------------------\n\n## Code walkthrough\n\n<br> <br>\n\nIf you want to follow along in your local R environment, you can clone the repository at this link:\n\n<br>\n\n[[https://github.com/JT-39/targets-coffee-code-walkthrough]({{< env url_code_walkthrough_git >}}){target=\"_blank\"}]{.link-underlined}\n\n------------------------------------------------------------------------\n\n## Setup\n\n<br><br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"targets\")\n```\n:::\n\n\n------------------------------------------------------------------------\n\n## Create an R project\n\n<br><br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::create_project(path = r\"(C:\\Users\\jtufts\\Documents\\targets-demo)\")\n```\n:::\n\n\n<br>\n\n::: callout-tip\n<section style=\"text-align: left;\">\n\nQuick plug that you can use my package to create a pre-populated R project directory!\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndauRtemplate::dau_proj_template(path = r\"(C:\\Users\\jtufts\\Documents\\targets-demo)\")\n```\n:::\n\n\n<br>\n\nMore information here: [[https://github.com/JT-39/dau-R-template-ext]({{< env url_dauR_template >}}){target=\"_blank\"}]{.link-underlined}\n\n</section>\n:::\n\n------------------------------------------------------------------------\n\n## Develop your data pipeline\n\n<br><br>\n\nThe project directory could look something like...\n\n<br>\n\n``` {.bash .code code-line-numbers=\"false\"}\n├── analysis.R\n├── _data/\n│   ├── raw_data.csv\n├── R/\n│   ├── functions.R\n```\n\n------------------------------------------------------------------------\n\n## Absence data\n\n<br>\n\n![](_images/absence_data.png){style=\"border: 2px solid grey;\"}\n\n------------------------------------------------------------------------\n\n## analysis.R\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(here::here(\"R/functions.R\"))\n\n# Path to absence data\nabsence_data_file_path <- here::here(\"_data/1_absence_3term_nat_reg_la.csv\")\n\n# Extract national absence and format date\ndf_nat_absence <- get_nat_absence_data(absence_data_file_path) |>\n  format_time_period()\n\n# Fit a linear model\nmodel <- fit_model(df_nat_absence)\n\n# Plot the data and model\nplot_model(model, df_nat_absence)\n```\n:::\n\n\n------------------------------------------------------------------------\n\n## functions.R\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Pull national absence from file\nget_nat_absence_data <- function(file_path) {\n  read.csv(file = file_path) |>\n    dplyr::filter(geographic_level == \"National\")\n}\n\n# Extract the start year from academic year\nextract_year <- function(date) {\n  paste0(substr(date, 1, 4))\n}\n\n# Format the year as a date\nformat_time_period <- function(data) {\n  data |>\n    dplyr::mutate(Date = lubridate::year(as.Date(extract_year(time_period),\n                                                 format = \"%Y\")),\n                  .after=time_period)\n}\n\n\n# Fit the model and pull coefficients\nfit_model <- function(data) {\n  lm(sess_overall_percent_pa_10_exact ~ Date, data) |>\n    coefficients()\n}\n\n# Round to the nearets multiple of five\nround_to_multiple_five <- function(x) {\n  ceiling((x + 1)/5)*5\n}\n\n# Plot the data and model\nplot_model <- function(model, data) {\n  ggplot2::ggplot(data) +\n    ggplot2::geom_point(ggplot2::aes(x = Date,\n                                     y = sess_overall_percent_pa_10_exact,\n                                     colour = school_type)) +\n    ggplot2::geom_line(ggplot2::aes(x = Date,\n                                     y = sess_overall_percent_pa_10_exact,\n                                     colour = school_type)) +\n    ggplot2::scale_colour_manual(values = kasstylesr::color_picker(4),\n                                 breaks = c(\"Total\", \"State-funded primary\",\n                                            \"State-funded secondary\", \"Special\")) +\n    ggplot2::geom_abline(intercept = model[1],\n                         slope = model[2],\n                         show.legend = T,\n                         colour=\"red\",\n                         linetype=\"dashed\") +\n    ggplot2::annotate(\"text\",\n                      x = max(data$Date),\n                      y = lm(sess_overall_percent_pa_10_exact ~ Date,\n                             df_nat_absence) |>\n                        fitted.values() |>\n                        max(),\n                      hjust = -0.45,\n                      label = \"Line of best fit\",\n                      colour = \"red\") +\n    ggplot2::scale_y_continuous(breaks = scales::pretty_breaks(),\n                                limits = function(x) {\n                                  c(0, round_to_multiple_five(max(x)))\n                                }) +\n    ggplot2::coord_cartesian(clip = 'off') +\n    ggplot2::theme_minimal() +\n    kasstylesr::kas_style() +\n    ggplot2::labs(\n      title = \"Average persistent absence over time in England\",\n      subtitle = \"Split by school type. Only includes persistent absentees.\",\n      x = \"\",\n      y = \"Overall absence rate (%)\",\n      colour = \"School type:\"\n    )\n}\n```\n:::\n\n\n------------------------------------------------------------------------\n\n## Outputs\n\n<section class=\"center\">\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(Intercept) \n    12.6906 \n```\n\n\n:::\n\n```{.r .cell-code}\nmodel[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        Date \n0.0004374435 \n```\n\n\n:::\n:::\n\n\n</section>\n\n------------------------------------------------------------------------\n\n## Outputs\n\n![](./_outputs/ab_plot.png){width=\"70%\" height=\"70%\"}\n\n------------------------------------------------------------------------\n\n## Now make a [{targets}]{style=\"color:#4758AB;\"} pipeline\n\n<br><br>\n\n``` {.bash .code code-line-numbers=\"false\"}\n├── _targets_analysis.R*\n├── _data/\n│   ├── raw_data.csv\n├── R/\n│   ├── functions.R\n```\n\n------------------------------------------------------------------------\n\n## Create a [{targets}]{style=\"color:#4758AB;\"} template\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntargets::tar_script()\n```\n:::\n\n\n<br>\n\n![](_images/tar_script.png){style=\"border: 2px solid grey;\"}\n\n------------------------------------------------------------------------\n\n## There are 3 parts to the pipeline\n\n<section class=\"left-align\">\n\n::: {.fragment .fade-in-then-semi-out}\n1.  Packages are loaded\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(targets)\n```\n:::\n\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n2.  Pipeline-specific options are set\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_option_set(packages = \"utils\")\ntar_source(here::here(\"R/functions.R\"))\n```\n:::\n\n:::\n\n::: {.fragment .fade-in}\n3.  The pipeline itself, a list of *targets*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist(\n  tar_target(name = data,\n             command = data.frame(x = sample.int(100),\n                                  y = sample.int(100))),\n  tar_target(name = data_summary,\n             command = summarize_data(data))\n)\n```\n:::\n\n:::\n\n</section>\n\n::: notes\n-   Due to the execution of the pipeline in parallel, load packages used in pipeline seperately.\n    -   So the pkgs are available to all workers.\n-   At the top of the script, think “pipeline infrastructure” packages ({targets} and some others).\n-   Inside tar_option_set() think “functions that run inside the pipeline” packages.\n:::\n\n------------------------------------------------------------------------\n\n## The [{targets}]{style=\"color:#4758AB;\"} pipeline\n\n<br><br>\n\n<section class=\"left-align\">\n\n::: {.fragment .fade-in-then-semi-out}\n-   It is simply a list of *targets* 🎯\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   A target is defined using `tar_target()`\n:::\n\n::: {.fragment .fade-in}\n-   Each has 2 necessary inputs\n    -   `name`\n    -   `command` \\~ the function that generates the target\n:::\n\n</section>\n\n------------------------------------------------------------------------\n\n## The [{targets}]{style=\"color:#4758AB;\"} pipeline\n\n<br>\n\n<section class=\"left-align\">\n\n::: fragment\nSo... a target defined as:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_target(name = y, command = f(x))\n```\n:::\n\n:::\n\n<br>\n\n::: {.fragment .fade-in}\nCan be understood as:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- f(x)\n```\n:::\n\n:::\n\n<br>\n\n::: {.fragment .fade-in}\n-   Targets after this can use the output of previous targets\n:::\n\n</section>\n\n::: notes\n-   A target is really just a step in the analysis pipeline\n:::\n\n------------------------------------------------------------------------\n\n## The [{targets}]{style=\"color:#4758AB;\"} pipeline\n\n<br>\n\n![](./_images/targets_pipeline.png){style=\"border: 2px solid grey;\"}\n\n------------------------------------------------------------------------\n\n## Build the pipeline\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntargets::tar_make()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n> dispatched target data_file\no completed target data_file [0.55 seconds]\n> dispatched target nat_data\no completed target nat_data [0.71 seconds]\n> dispatched target nat_data_clean\no completed target nat_data_clean [0.01 seconds]\n> dispatched target model\no completed target model [0 seconds]\nSaving 7 x 7 in image\n> dispatched target plot\no completed target plot [0.81 seconds]\n> ended pipeline [2.29 seconds]\n```\n\n\n:::\n:::\n\n\n::: {.fragment .fade-up}\n::: callout-tip\n<section class=\"left-align\">\n\nUse the code below to set which script the {`target`} functions default to:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntargets::tar_config_set(script = \"src/_targets_analysis.R\")\n```\n:::\n\n\n</section>\n:::\n:::\n\n------------------------------------------------------------------------\n\n## An empty global environment?\n\n<br>\n\n![](_images/empty_environment.png){style=\"border: 2px solid grey;\"}\n\n------------------------------------------------------------------------\n\n## What is going on?\n\n<br><br>\n\n<section class=\"left-align\">\n\n::: {.fragment .fade-in-then-semi-out}\n-   {`targets`} creates a pipeline of pure functions\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   Running the pipeline does not depend on the global environment 🌍\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   It also does not change anything outside its scope 🔭\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   The pipeline is **PURE**\n:::\n\n</section>\n\n------------------------------------------------------------------------\n\n## <span style = \"color:#4758AB;\">\\_targets/</span>\n\n<br><br>\n\n<section class=\"left-align\">\n\n::: {.fragment .fade-in-then-semi-out}\n-   The outputs are stored in `_targets/objects/`\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   Each target is saved as an object in the `.rds` format\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   So, you **MUST** add `_targets/` to `.gitignore` (for GitHub) ☝️\n:::\n\n</section>\n\n------------------------------------------------------------------------\n\n## <span style = \"color:#4758AB;\">\\_targets/</span>\n\n<br>\n\n``` {.bash .code code-line-numbers=\"false\"}\n_targets/\n├── meta\n│   ├── meta\n│   ├── process\n│   └── progress\n├── objects\n│   ├── model\n│   ├── nat_data\n│   └── nat_data_clean\n└── user\n```\n\n<br>\n\n::: {.fragment .fade-in-then}\n![](_images/_targets_objects.png){style=\"border: 2px solid grey;\"}\n:::\n\n------------------------------------------------------------------------\n\n## <span style = \"color:#4758AB;\">\\_targets/</span>\n\n<br>\n\n<section class=\"left-align\">\n\nTo display targets:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_read(model)[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(Intercept) \n    12.6906 \n```\n\n\n:::\n:::\n\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_read(model)[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        Date \n0.0004374435 \n```\n\n\n:::\n:::\n\n\n</section>\n\n::: notes\n-   Well not strictly pure...\n-   `.rds` is a R-specific format to save *any* type of object\n-   Can be save and read with `saveRDS()` and `readRDS()`\n-   Also should note that the pipeline is composition of pure functions.\n-   Pure functions:\n    -   Referentially transparent function is a function that does not use any variable that is not also one of its inputs.\n    -   A function that does not interact in any way with the global environment.\n-   Functions with only side-effects will be difficult to handle. For example, `base::plot()`\n:::\n\n------------------------------------------------------------------------\n\n## <span style = \"color:#4758AB;\">\\_targets/</span>\n\n<br>\n\n<section class=\"left-align\">\n\nTo load targets into the global environment:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_load(model)\n```\n:::\n\n\n</section>\n\n<br> <br> <br>\n\n![](_images/tar_load_global_env.png){style=\"border: 2px solid grey;\"}\n\n------------------------------------------------------------------------\n\n## Plots are different\n\n::: {.callout-warning title=\"Advanced\"}\n<section class=\"left-align\">\n\n::: {.fragment .fade-in-then-semi-out}\n-   A `target` must have a \"physical\" output. (Base plot produces side-effects... 🤒)\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   Luckily {`ggplot2`} produces plots as an output.\n:::\n::: {.fragment .fade-in-then-semi-out}\n-   But we probably want to save them somewhere!\n:::\n\n::: {.fragment .fade-in}\nSo we use `ggsave()` at the end of the plotting function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot <- ggplot(...)\n\nggplot2::ggsave(here::here(\"_outputs/ab_plot.png\"),\n                plot = plot)\n\nreturn(\"_outputs/ab_plot.png\")\n```\n:::\n\n:::\n\n::: {.fragment .fade-in}\n-   **NOTE**: We return the file path to keep {`targets`} happy 😇\n:::\n\n</section>\n:::\n\n------------------------------------------------------------------------\n\n## File Big Brother\n\n<br><br>\n\n<section class=\"left-align\">\n\n::: {.fragment .fade-in-then-semi-out}\n-   {`targets`} keeps track of changes in files and functions 🕵️\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   Any changes will result in the targets being identified as out-of-date\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   So, are re-computed (and their dependencies)\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   We can visualise this...\n:::\n\n</section>\n\n------------------------------------------------------------------------\n\n## Code dependency graph\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntargets::tar_visnetwork(script = \"_targets_analysis.R\")\n```\n:::\n\n\n![](./_images/complete_code_dependency_graph.png){style=\"border: 2px solid grey;\"}\n\n------------------------------------------------------------------------\n\n## Let's change something\n\n<br><br>\n\n<section style=\"text-align: left;\">\n\n::: {.fragment .fade-in}\n-   We now filter out the years 2020 & 2021\n\n\n::: {.cell}\n\n```{.r .cell-code}\nformat_time_period <- function(data) {\n  data |>\n    ... |>\n    dplyr::filter(!Date %in% c(2020, 2021))\n}\n```\n:::\n\n:::\n\n</section>\n\n------------------------------------------------------------------------\n\n## Let's change something\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntargets::tar_visnetwork(script = \"_targets_analysis.R\")\n```\n:::\n\n\n::: {.fragment .fade-in width=\"450\" height=\"300\"}\n![](./_images/incomplete_code_dependency_graph.png){style=\"border: 2px solid grey;\"}\n:::\n\n::: notes\n-   The graph will also highlight in red if there is an error in the pipeline.\n:::\n\n------------------------------------------------------------------------\n\n## Steps skipped\n\n<br> <br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntargets::tar_make()\n```\n:::\n\n\n<br>\n\n```{{r}}\nv skipped target data_file\nv skipped target nat_data\n> dispatched target nat_data_clean\no completed target nat_data_clean [0.03 seconds]\nv skipped target model\nv skipped target plot\n> ended pipeline [2.5 seconds]\n```\n\n------------------------------------------------------------------------\n\n## These can be embedded graphs...\n\n<br>\n\n\n```{mermaid}\n%%| label: mermaid-code-gph\n%%| eval: true\n%%| echo: false\n\ngraph LR\nstyle Legend fill:#FFFFFF00,stroke:#000000\nstyle Graph fill:#FFFFFF00,stroke:#000000;\n  subgraph Legend\n    direction LR\n    xf1522833a4d242c5([Up to date]):::uptodate --- xd03d7c7dd2ddda2b([Stem]):::none\n    xd03d7c7dd2ddda2b([Stem]):::none --- xeb2d7cac8a1ce544>Function]:::none\n  end\n  subgraph Graph\n    direction LR\n    xb1fbb690b4ec8c10>extract_year]:::uptodate --> xd20a83ce47f3194c>format_time_period]:::uptodate\n    xf7d598eca7911241>round_to_multiple_five]:::uptodate --> xec203b5a68d60f72>plot_model]:::uptodate\n    xd20a83ce47f3194c>format_time_period]:::uptodate --> xc2980a3d74445b80([nat_data_clean]):::uptodate\n    x83c942fcaf37c3dc([nat_data]):::uptodate --> xc2980a3d74445b80([nat_data_clean]):::uptodate\n    x0d01c84c9424364d([data_file]):::uptodate --> x83c942fcaf37c3dc([nat_data]):::uptodate\n    x9242f8c59a209716>get_nat_absence_data]:::uptodate --> x83c942fcaf37c3dc([nat_data]):::uptodate\n    x9043e9d6bef6a839([model]):::uptodate --> x667cd56a75e2bb2b([plot]):::uptodate\n    xc2980a3d74445b80([nat_data_clean]):::uptodate --> x667cd56a75e2bb2b([plot]):::uptodate\n    xec203b5a68d60f72>plot_model]:::uptodate --> x667cd56a75e2bb2b([plot]):::uptodate\n    x12e88730e39644dc>fit_model]:::uptodate --> x9043e9d6bef6a839([model]):::uptodate\n    xc2980a3d74445b80([nat_data_clean]):::uptodate --> x9043e9d6bef6a839([model]):::uptodate\n  end\nclassDef uptodate stroke:#000000,color:#ffffff,fill:#354823;\nclassDef none stroke:#000000,color:#000000,fill:#94a4ac;\nlinkStyle 0 stroke-width:0px;\nlinkStyle 1 stroke-width:0px;\n\n```\n\n\n------------------------------------------------------------------------\n\n## ... or save them as a .html\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhtmltools::save_html(html = targets::tar_visnetwork(\"_targets_analysis.R\"),\n                     file = \"_outputs/code_pipeline.html\")\n```\n:::\n\n\n::: {.fragment .fade-in width=\"450\" height=\"300\"}\n![](./_images/errored_code_dependency_graph.png){style=\"border: 2px solid grey;\" height=\"450\" width=\"800\"}\n:::\n\n------------------------------------------------------------------------\n\n## Handling files\n\n<br>\n\n::: {.callout-warning title=\"Advanced\"}\n<section class=\"left-align\">\n\n::: {.fragment .fade-in}\n-   **MUST** use the data's file path initially (and `format = \"file\"`)\n:::\n\n::: {.fragment .fade-in}\n\n::: {.cell}\n\n```{.r .cell-code}\ntargets::tar_target(\n    name = data,\n    command = here::here(\"_data/1_absence_3term_nat_reg_la.csv\"),\n    format = \"file\"\n)\n```\n:::\n\n:::\n\n::: {.fragment .fade-in}\n-   Then use the file path target to read in the data 📖\n:::\n\n::: {.fragment .fade-in}\n\n::: {.cell}\n\n```{.r .cell-code}\ntargets::tar_target(\n    name = nat_data,\n    command = read.csv(data)\n)\n```\n:::\n\n:::\n\n::: {.fragment .fade-in}\n-   Otherwise, {`targets`} will not track the data (any changes to it) 😴\n:::\n\n</section>\n:::\n\n------------------------------------------------------------------------\n\n## Parallel computation\n\n<br>\n\n<section class=\"left-align\">\n\n::: {.fragment .fade-in-then-semi-out}\n-   Can run any independent steps (*targets*) in parallel 🔀\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   We are able to harness any GPU cores available, cutting computation time ✂️\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   {`targets`} knows which parts of the pipeline can be ran in parallel\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   To set this up...\n:::\n\n</section>\n\n::: notes\n-   Also could be useful on DataBricks where more cores and nodes may be available.\n:::\n\n------------------------------------------------------------------------\n\n## Parallel computation\n\n<br>\n\n<section class=\"left-align\">\n\n::: {.fragment .fade-in-then-out}\nNeed to load a few more packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(targets)\nlibrary(future)\nlibrary(future.callr)\nplan(callr)\n```\n:::\n\n:::\n\n::: {.fragment .fade-in-then-out}\nUtilise the {`targets`} function to run in parallel:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set workers = 2 to use 2 cpu cores\ntargets::tar_make_future(workers = 2)\n```\n:::\n\n:::\n\n::: {.fragment .fade-in}\nSimple as that! 💥\n:::\n\n</section>\n\n::: notes\n-   Most of our laptops have around 7 cores.\n-   Don't use all the cores though as some are needed for background computer stuff!\n:::\n\n------------------------------------------------------------------------\n\n## Other features {.center}\n\n🔮\n\n------------------------------------------------------------------------\n\n## RMarkdown & Quarto\n\n<br>\n\n<section style=\"text-align: left;\">\n\n::: {.fragment .fade-in-then-semi-out}\n-   Can include the rendering of a `.Rmd` or `.qmd` to the pipeline\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   Utilises the power of the {`targets`} computation 🔋\n:::\n\n<br>\n\n::: r-stack\n::: {.fragment .fade-in-then-out}\nLoad package needed\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibray(tarchetypes)\n```\n:::\n\n:::\n\n::: {.fragment .fade-in-then-out}\nFunction to render Quarto file in the pipeline\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_render(\n  my_doc,\n  \"my_document.qmd\"\n)\n```\n:::\n\n:::\n\n::: {.fragment .fade-in-then-out}\nHow to load targets in the Quarto file\n\n```{{r}}\ntar_read(plot)\n```\n:::\n:::\n\n</section>\n\n------------------------------------------------------------------------\n\n## SQL\n\n<section class=\"left-align\">\n\n::: {.fragment .fade-in-then-out}\n-   When executing code to SQL you will need to create connect and disconnect each time 🔌\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunction(yml_key) {\n  conn <- connect_sql_db(yml_key)\n  on.exit(DBI::dbDisconnect(conn, shutdown = TRUE))\n\n  DBI::dbGetQuery(...)}\n```\n:::\n\n:::\n\n::: {.fragment .fade-in}\n-   Also the package {`sqltargets`} which applies {`targets`} principles to .sql files 📦\n:::\n\n::: r-stack\n::: {.fragment .fade-in-then-out}\n\n::: {.cell}\n\n```{.sql .cell-code}\n-- !preview conn=DBI::dbConnect(RSQLite::SQLite())\n-- tar_load(query_params)\nselect id\nfrom table\nwhere age > {age_threshold}\n```\n:::\n\n:::\n\n::: {.fragment .fade-in}\n\n::: {.cell}\n\n```{.r .cell-code}\ntar_sql(query, path = \"query.sql\", query_params = query_params)\n```\n:::\n\n:::\n:::\n\n</section>\n\n::: notes\n-   SQL connection repetitio is to ensure the connection is closed and is reusable\n:::\n\n------------------------------------------------------------------------\n\n## Key takeaways\n\n<br><br>\n\n<section class=\"left-align\">\n\n::: {.fragment .fade-in-then-semi-out}\n-   Enforces a modular, function based pipelines ✅ <br>(R best practice!)\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   Tracks changes to datasets and functions 🔍\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n-   Provides efficient computation of pipelines ♻️\n:::\n\n</section>\n\n------------------------------------------------------------------------\n\n## We've hit the target! {.center}\n\n🎯\n\n------------------------------------------------------------------------\n\n## Resources, links and email\n\n<br>\n\n<section class=\"left-align\">\n\n-   {targets} manual: [[Link]({{< env targets_pkg_manual >}}){target=\"_blank\"}]{.link-underlined}\n\n-   YouTube {targets} walkthrough: [[Link]({{< env youtube_targets >}}){target=\"_blank\"}]{.link-underlined}\n\n-   Ofsted MI {targets} example pipeline GitHub: [[Link]({{< env ofsted_mi_github >}}){target=\"_blank\"}]{.link-underlined}\n\n-   These slides and mini {targets} example GitHub: [[Link]({{< env slides_github >}}){target=\"_blank\"}]{.link-underlined}\n\n-   {sqltargets} GitHub: [[Link]({{< env sql_targets_git >}}){target=\"_blank\"}]{.link-underlined}\n\n-   Building reproducible analytical pipelines with R: [[Link]({{< env bruno_targets >}}){target=\"_blank\"}]{.link-underlined}\n\nEmail me at:\n\n[jake.tufts\\@education.gov.uk]{style=\"color:#4758AB;\"}\n\n</section>\n\n------------------------------------------------------------------------\n\n## Example of a larger pipeline {.scrollable}\n\n<br>\n\n[Ofsted MI {targets} example pipeline GitHub]({{< env ofsted_mi_github >}}){target=\"_blank\"}\n\n![Process map](_images/ofsted-mi-process-map.jpg)\n\n![Targets pipeline](_images/ofsted_targets_pipeline.png)\n",
    "supporting": [
      "intro-targets_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}